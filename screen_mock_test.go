package tcg

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/gdamore/tcell/v2.Screen -o ./screen_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_tcell "github.com/gdamore/tcell/v2"
	"github.com/gojuno/minimock/v3"
)

// ScreenMock implements tcell.Screen
type ScreenMock struct {
	t minimock.Tester

	funcBeep          func() (err error)
	inspectFuncBeep   func()
	afterBeepCounter  uint64
	beforeBeepCounter uint64
	BeepMock          mScreenMockBeep

	funcCanDisplay          func(r rune, checkFallbacks bool) (b1 bool)
	inspectFuncCanDisplay   func(r rune, checkFallbacks bool)
	afterCanDisplayCounter  uint64
	beforeCanDisplayCounter uint64
	CanDisplayMock          mScreenMockCanDisplay

	funcCharacterSet          func() (s1 string)
	inspectFuncCharacterSet   func()
	afterCharacterSetCounter  uint64
	beforeCharacterSetCounter uint64
	CharacterSetMock          mScreenMockCharacterSet

	funcClear          func()
	inspectFuncClear   func()
	afterClearCounter  uint64
	beforeClearCounter uint64
	ClearMock          mScreenMockClear

	funcColors          func() (i1 int)
	inspectFuncColors   func()
	afterColorsCounter  uint64
	beforeColorsCounter uint64
	ColorsMock          mScreenMockColors

	funcDisableMouse          func()
	inspectFuncDisableMouse   func()
	afterDisableMouseCounter  uint64
	beforeDisableMouseCounter uint64
	DisableMouseMock          mScreenMockDisableMouse

	funcDisablePaste          func()
	inspectFuncDisablePaste   func()
	afterDisablePasteCounter  uint64
	beforeDisablePasteCounter uint64
	DisablePasteMock          mScreenMockDisablePaste

	funcEnableMouse          func()
	inspectFuncEnableMouse   func()
	afterEnableMouseCounter  uint64
	beforeEnableMouseCounter uint64
	EnableMouseMock          mScreenMockEnableMouse

	funcEnablePaste          func()
	inspectFuncEnablePaste   func()
	afterEnablePasteCounter  uint64
	beforeEnablePasteCounter uint64
	EnablePasteMock          mScreenMockEnablePaste

	funcFill          func(r1 rune, s1 mm_tcell.Style)
	inspectFuncFill   func(r1 rune, s1 mm_tcell.Style)
	afterFillCounter  uint64
	beforeFillCounter uint64
	FillMock          mScreenMockFill

	funcFini          func()
	inspectFuncFini   func()
	afterFiniCounter  uint64
	beforeFiniCounter uint64
	FiniMock          mScreenMockFini

	funcGetContent          func(x int, y int) (mainc rune, combc []rune, style mm_tcell.Style, width int)
	inspectFuncGetContent   func(x int, y int)
	afterGetContentCounter  uint64
	beforeGetContentCounter uint64
	GetContentMock          mScreenMockGetContent

	funcHasKey          func(k1 mm_tcell.Key) (b1 bool)
	inspectFuncHasKey   func(k1 mm_tcell.Key)
	afterHasKeyCounter  uint64
	beforeHasKeyCounter uint64
	HasKeyMock          mScreenMockHasKey

	funcHasMouse          func() (b1 bool)
	inspectFuncHasMouse   func()
	afterHasMouseCounter  uint64
	beforeHasMouseCounter uint64
	HasMouseMock          mScreenMockHasMouse

	funcHideCursor          func()
	inspectFuncHideCursor   func()
	afterHideCursorCounter  uint64
	beforeHideCursorCounter uint64
	HideCursorMock          mScreenMockHideCursor

	funcInit          func() (err error)
	inspectFuncInit   func()
	afterInitCounter  uint64
	beforeInitCounter uint64
	InitMock          mScreenMockInit

	funcPollEvent          func() (e1 mm_tcell.Event)
	inspectFuncPollEvent   func()
	afterPollEventCounter  uint64
	beforePollEventCounter uint64
	PollEventMock          mScreenMockPollEvent

	funcPostEvent          func(ev mm_tcell.Event) (err error)
	inspectFuncPostEvent   func(ev mm_tcell.Event)
	afterPostEventCounter  uint64
	beforePostEventCounter uint64
	PostEventMock          mScreenMockPostEvent

	funcPostEventWait          func(ev mm_tcell.Event)
	inspectFuncPostEventWait   func(ev mm_tcell.Event)
	afterPostEventWaitCounter  uint64
	beforePostEventWaitCounter uint64
	PostEventWaitMock          mScreenMockPostEventWait

	funcRegisterRuneFallback          func(r rune, subst string)
	inspectFuncRegisterRuneFallback   func(r rune, subst string)
	afterRegisterRuneFallbackCounter  uint64
	beforeRegisterRuneFallbackCounter uint64
	RegisterRuneFallbackMock          mScreenMockRegisterRuneFallback

	funcResize          func(i1 int, i2 int, i3 int, i4 int)
	inspectFuncResize   func(i1 int, i2 int, i3 int, i4 int)
	afterResizeCounter  uint64
	beforeResizeCounter uint64
	ResizeMock          mScreenMockResize

	funcSetCell          func(x int, y int, style mm_tcell.Style, ch ...rune)
	inspectFuncSetCell   func(x int, y int, style mm_tcell.Style, ch ...rune)
	afterSetCellCounter  uint64
	beforeSetCellCounter uint64
	SetCellMock          mScreenMockSetCell

	funcSetContent          func(x int, y int, mainc rune, combc []rune, style mm_tcell.Style)
	inspectFuncSetContent   func(x int, y int, mainc rune, combc []rune, style mm_tcell.Style)
	afterSetContentCounter  uint64
	beforeSetContentCounter uint64
	SetContentMock          mScreenMockSetContent

	funcSetStyle          func(style mm_tcell.Style)
	inspectFuncSetStyle   func(style mm_tcell.Style)
	afterSetStyleCounter  uint64
	beforeSetStyleCounter uint64
	SetStyleMock          mScreenMockSetStyle

	funcShow          func()
	inspectFuncShow   func()
	afterShowCounter  uint64
	beforeShowCounter uint64
	ShowMock          mScreenMockShow

	funcShowCursor          func(x int, y int)
	inspectFuncShowCursor   func(x int, y int)
	afterShowCursorCounter  uint64
	beforeShowCursorCounter uint64
	ShowCursorMock          mScreenMockShowCursor

	funcSize          func() (i1 int, i2 int)
	inspectFuncSize   func()
	afterSizeCounter  uint64
	beforeSizeCounter uint64
	SizeMock          mScreenMockSize

	funcSync          func()
	inspectFuncSync   func()
	afterSyncCounter  uint64
	beforeSyncCounter uint64
	SyncMock          mScreenMockSync

	funcUnregisterRuneFallback          func(r rune)
	inspectFuncUnregisterRuneFallback   func(r rune)
	afterUnregisterRuneFallbackCounter  uint64
	beforeUnregisterRuneFallbackCounter uint64
	UnregisterRuneFallbackMock          mScreenMockUnregisterRuneFallback
}

// NewScreenMock returns a mock for tcell.Screen
func NewScreenMock(t minimock.Tester) *ScreenMock {
	m := &ScreenMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeepMock = mScreenMockBeep{mock: m}

	m.CanDisplayMock = mScreenMockCanDisplay{mock: m}
	m.CanDisplayMock.callArgs = []*ScreenMockCanDisplayParams{}

	m.CharacterSetMock = mScreenMockCharacterSet{mock: m}

	m.ClearMock = mScreenMockClear{mock: m}

	m.ColorsMock = mScreenMockColors{mock: m}

	m.DisableMouseMock = mScreenMockDisableMouse{mock: m}

	m.DisablePasteMock = mScreenMockDisablePaste{mock: m}

	m.EnableMouseMock = mScreenMockEnableMouse{mock: m}

	m.EnablePasteMock = mScreenMockEnablePaste{mock: m}

	m.FillMock = mScreenMockFill{mock: m}
	m.FillMock.callArgs = []*ScreenMockFillParams{}

	m.FiniMock = mScreenMockFini{mock: m}

	m.GetContentMock = mScreenMockGetContent{mock: m}
	m.GetContentMock.callArgs = []*ScreenMockGetContentParams{}

	m.HasKeyMock = mScreenMockHasKey{mock: m}
	m.HasKeyMock.callArgs = []*ScreenMockHasKeyParams{}

	m.HasMouseMock = mScreenMockHasMouse{mock: m}

	m.HideCursorMock = mScreenMockHideCursor{mock: m}

	m.InitMock = mScreenMockInit{mock: m}

	m.PollEventMock = mScreenMockPollEvent{mock: m}

	m.PostEventMock = mScreenMockPostEvent{mock: m}
	m.PostEventMock.callArgs = []*ScreenMockPostEventParams{}

	m.PostEventWaitMock = mScreenMockPostEventWait{mock: m}
	m.PostEventWaitMock.callArgs = []*ScreenMockPostEventWaitParams{}

	m.RegisterRuneFallbackMock = mScreenMockRegisterRuneFallback{mock: m}
	m.RegisterRuneFallbackMock.callArgs = []*ScreenMockRegisterRuneFallbackParams{}

	m.ResizeMock = mScreenMockResize{mock: m}
	m.ResizeMock.callArgs = []*ScreenMockResizeParams{}

	m.SetCellMock = mScreenMockSetCell{mock: m}
	m.SetCellMock.callArgs = []*ScreenMockSetCellParams{}

	m.SetContentMock = mScreenMockSetContent{mock: m}
	m.SetContentMock.callArgs = []*ScreenMockSetContentParams{}

	m.SetStyleMock = mScreenMockSetStyle{mock: m}
	m.SetStyleMock.callArgs = []*ScreenMockSetStyleParams{}

	m.ShowMock = mScreenMockShow{mock: m}

	m.ShowCursorMock = mScreenMockShowCursor{mock: m}
	m.ShowCursorMock.callArgs = []*ScreenMockShowCursorParams{}

	m.SizeMock = mScreenMockSize{mock: m}

	m.SyncMock = mScreenMockSync{mock: m}

	m.UnregisterRuneFallbackMock = mScreenMockUnregisterRuneFallback{mock: m}
	m.UnregisterRuneFallbackMock.callArgs = []*ScreenMockUnregisterRuneFallbackParams{}

	return m
}

type mScreenMockBeep struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockBeepExpectation
	expectations       []*ScreenMockBeepExpectation
}

// ScreenMockBeepExpectation specifies expectation struct of the Screen.Beep
type ScreenMockBeepExpectation struct {
	mock *ScreenMock

	results *ScreenMockBeepResults
	Counter uint64
}

// ScreenMockBeepResults contains results of the Screen.Beep
type ScreenMockBeepResults struct {
	err error
}

// Expect sets up expected params for Screen.Beep
func (mmBeep *mScreenMockBeep) Expect() *mScreenMockBeep {
	if mmBeep.mock.funcBeep != nil {
		mmBeep.mock.t.Fatalf("ScreenMock.Beep mock is already set by Set")
	}

	if mmBeep.defaultExpectation == nil {
		mmBeep.defaultExpectation = &ScreenMockBeepExpectation{}
	}

	return mmBeep
}

// Inspect accepts an inspector function that has same arguments as the Screen.Beep
func (mmBeep *mScreenMockBeep) Inspect(f func()) *mScreenMockBeep {
	if mmBeep.mock.inspectFuncBeep != nil {
		mmBeep.mock.t.Fatalf("Inspect function is already set for ScreenMock.Beep")
	}

	mmBeep.mock.inspectFuncBeep = f

	return mmBeep
}

// Return sets up results that will be returned by Screen.Beep
func (mmBeep *mScreenMockBeep) Return(err error) *ScreenMock {
	if mmBeep.mock.funcBeep != nil {
		mmBeep.mock.t.Fatalf("ScreenMock.Beep mock is already set by Set")
	}

	if mmBeep.defaultExpectation == nil {
		mmBeep.defaultExpectation = &ScreenMockBeepExpectation{mock: mmBeep.mock}
	}
	mmBeep.defaultExpectation.results = &ScreenMockBeepResults{err}
	return mmBeep.mock
}

//Set uses given function f to mock the Screen.Beep method
func (mmBeep *mScreenMockBeep) Set(f func() (err error)) *ScreenMock {
	if mmBeep.defaultExpectation != nil {
		mmBeep.mock.t.Fatalf("Default expectation is already set for the Screen.Beep method")
	}

	if len(mmBeep.expectations) > 0 {
		mmBeep.mock.t.Fatalf("Some expectations are already set for the Screen.Beep method")
	}

	mmBeep.mock.funcBeep = f
	return mmBeep.mock
}

// Beep implements tcell.Screen
func (mmBeep *ScreenMock) Beep() (err error) {
	mm_atomic.AddUint64(&mmBeep.beforeBeepCounter, 1)
	defer mm_atomic.AddUint64(&mmBeep.afterBeepCounter, 1)

	if mmBeep.inspectFuncBeep != nil {
		mmBeep.inspectFuncBeep()
	}

	if mmBeep.BeepMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeep.BeepMock.defaultExpectation.Counter, 1)

		mm_results := mmBeep.BeepMock.defaultExpectation.results
		if mm_results == nil {
			mmBeep.t.Fatal("No results are set for the ScreenMock.Beep")
		}
		return (*mm_results).err
	}
	if mmBeep.funcBeep != nil {
		return mmBeep.funcBeep()
	}
	mmBeep.t.Fatalf("Unexpected call to ScreenMock.Beep.")
	return
}

// BeepAfterCounter returns a count of finished ScreenMock.Beep invocations
func (mmBeep *ScreenMock) BeepAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeep.afterBeepCounter)
}

// BeepBeforeCounter returns a count of ScreenMock.Beep invocations
func (mmBeep *ScreenMock) BeepBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeep.beforeBeepCounter)
}

// MinimockBeepDone returns true if the count of the Beep invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockBeepDone() bool {
	for _, e := range m.BeepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeepCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeep != nil && mm_atomic.LoadUint64(&m.afterBeepCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeepInspect logs each unmet expectation
func (m *ScreenMock) MinimockBeepInspect() {
	for _, e := range m.BeepMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.Beep")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeepMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeepCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Beep")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeep != nil && mm_atomic.LoadUint64(&m.afterBeepCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Beep")
	}
}

type mScreenMockCanDisplay struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockCanDisplayExpectation
	expectations       []*ScreenMockCanDisplayExpectation

	callArgs []*ScreenMockCanDisplayParams
	mutex    sync.RWMutex
}

// ScreenMockCanDisplayExpectation specifies expectation struct of the Screen.CanDisplay
type ScreenMockCanDisplayExpectation struct {
	mock    *ScreenMock
	params  *ScreenMockCanDisplayParams
	results *ScreenMockCanDisplayResults
	Counter uint64
}

// ScreenMockCanDisplayParams contains parameters of the Screen.CanDisplay
type ScreenMockCanDisplayParams struct {
	r              rune
	checkFallbacks bool
}

// ScreenMockCanDisplayResults contains results of the Screen.CanDisplay
type ScreenMockCanDisplayResults struct {
	b1 bool
}

// Expect sets up expected params for Screen.CanDisplay
func (mmCanDisplay *mScreenMockCanDisplay) Expect(r rune, checkFallbacks bool) *mScreenMockCanDisplay {
	if mmCanDisplay.mock.funcCanDisplay != nil {
		mmCanDisplay.mock.t.Fatalf("ScreenMock.CanDisplay mock is already set by Set")
	}

	if mmCanDisplay.defaultExpectation == nil {
		mmCanDisplay.defaultExpectation = &ScreenMockCanDisplayExpectation{}
	}

	mmCanDisplay.defaultExpectation.params = &ScreenMockCanDisplayParams{r, checkFallbacks}
	for _, e := range mmCanDisplay.expectations {
		if minimock.Equal(e.params, mmCanDisplay.defaultExpectation.params) {
			mmCanDisplay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCanDisplay.defaultExpectation.params)
		}
	}

	return mmCanDisplay
}

// Inspect accepts an inspector function that has same arguments as the Screen.CanDisplay
func (mmCanDisplay *mScreenMockCanDisplay) Inspect(f func(r rune, checkFallbacks bool)) *mScreenMockCanDisplay {
	if mmCanDisplay.mock.inspectFuncCanDisplay != nil {
		mmCanDisplay.mock.t.Fatalf("Inspect function is already set for ScreenMock.CanDisplay")
	}

	mmCanDisplay.mock.inspectFuncCanDisplay = f

	return mmCanDisplay
}

// Return sets up results that will be returned by Screen.CanDisplay
func (mmCanDisplay *mScreenMockCanDisplay) Return(b1 bool) *ScreenMock {
	if mmCanDisplay.mock.funcCanDisplay != nil {
		mmCanDisplay.mock.t.Fatalf("ScreenMock.CanDisplay mock is already set by Set")
	}

	if mmCanDisplay.defaultExpectation == nil {
		mmCanDisplay.defaultExpectation = &ScreenMockCanDisplayExpectation{mock: mmCanDisplay.mock}
	}
	mmCanDisplay.defaultExpectation.results = &ScreenMockCanDisplayResults{b1}
	return mmCanDisplay.mock
}

//Set uses given function f to mock the Screen.CanDisplay method
func (mmCanDisplay *mScreenMockCanDisplay) Set(f func(r rune, checkFallbacks bool) (b1 bool)) *ScreenMock {
	if mmCanDisplay.defaultExpectation != nil {
		mmCanDisplay.mock.t.Fatalf("Default expectation is already set for the Screen.CanDisplay method")
	}

	if len(mmCanDisplay.expectations) > 0 {
		mmCanDisplay.mock.t.Fatalf("Some expectations are already set for the Screen.CanDisplay method")
	}

	mmCanDisplay.mock.funcCanDisplay = f
	return mmCanDisplay.mock
}

// When sets expectation for the Screen.CanDisplay which will trigger the result defined by the following
// Then helper
func (mmCanDisplay *mScreenMockCanDisplay) When(r rune, checkFallbacks bool) *ScreenMockCanDisplayExpectation {
	if mmCanDisplay.mock.funcCanDisplay != nil {
		mmCanDisplay.mock.t.Fatalf("ScreenMock.CanDisplay mock is already set by Set")
	}

	expectation := &ScreenMockCanDisplayExpectation{
		mock:   mmCanDisplay.mock,
		params: &ScreenMockCanDisplayParams{r, checkFallbacks},
	}
	mmCanDisplay.expectations = append(mmCanDisplay.expectations, expectation)
	return expectation
}

// Then sets up Screen.CanDisplay return parameters for the expectation previously defined by the When method
func (e *ScreenMockCanDisplayExpectation) Then(b1 bool) *ScreenMock {
	e.results = &ScreenMockCanDisplayResults{b1}
	return e.mock
}

// CanDisplay implements tcell.Screen
func (mmCanDisplay *ScreenMock) CanDisplay(r rune, checkFallbacks bool) (b1 bool) {
	mm_atomic.AddUint64(&mmCanDisplay.beforeCanDisplayCounter, 1)
	defer mm_atomic.AddUint64(&mmCanDisplay.afterCanDisplayCounter, 1)

	if mmCanDisplay.inspectFuncCanDisplay != nil {
		mmCanDisplay.inspectFuncCanDisplay(r, checkFallbacks)
	}

	mm_params := &ScreenMockCanDisplayParams{r, checkFallbacks}

	// Record call args
	mmCanDisplay.CanDisplayMock.mutex.Lock()
	mmCanDisplay.CanDisplayMock.callArgs = append(mmCanDisplay.CanDisplayMock.callArgs, mm_params)
	mmCanDisplay.CanDisplayMock.mutex.Unlock()

	for _, e := range mmCanDisplay.CanDisplayMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmCanDisplay.CanDisplayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCanDisplay.CanDisplayMock.defaultExpectation.Counter, 1)
		mm_want := mmCanDisplay.CanDisplayMock.defaultExpectation.params
		mm_got := ScreenMockCanDisplayParams{r, checkFallbacks}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCanDisplay.t.Errorf("ScreenMock.CanDisplay got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCanDisplay.CanDisplayMock.defaultExpectation.results
		if mm_results == nil {
			mmCanDisplay.t.Fatal("No results are set for the ScreenMock.CanDisplay")
		}
		return (*mm_results).b1
	}
	if mmCanDisplay.funcCanDisplay != nil {
		return mmCanDisplay.funcCanDisplay(r, checkFallbacks)
	}
	mmCanDisplay.t.Fatalf("Unexpected call to ScreenMock.CanDisplay. %v %v", r, checkFallbacks)
	return
}

// CanDisplayAfterCounter returns a count of finished ScreenMock.CanDisplay invocations
func (mmCanDisplay *ScreenMock) CanDisplayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanDisplay.afterCanDisplayCounter)
}

// CanDisplayBeforeCounter returns a count of ScreenMock.CanDisplay invocations
func (mmCanDisplay *ScreenMock) CanDisplayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanDisplay.beforeCanDisplayCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.CanDisplay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCanDisplay *mScreenMockCanDisplay) Calls() []*ScreenMockCanDisplayParams {
	mmCanDisplay.mutex.RLock()

	argCopy := make([]*ScreenMockCanDisplayParams, len(mmCanDisplay.callArgs))
	copy(argCopy, mmCanDisplay.callArgs)

	mmCanDisplay.mutex.RUnlock()

	return argCopy
}

// MinimockCanDisplayDone returns true if the count of the CanDisplay invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockCanDisplayDone() bool {
	for _, e := range m.CanDisplayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CanDisplayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCanDisplayCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanDisplay != nil && mm_atomic.LoadUint64(&m.afterCanDisplayCounter) < 1 {
		return false
	}
	return true
}

// MinimockCanDisplayInspect logs each unmet expectation
func (m *ScreenMock) MinimockCanDisplayInspect() {
	for _, e := range m.CanDisplayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.CanDisplay with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CanDisplayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCanDisplayCounter) < 1 {
		if m.CanDisplayMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.CanDisplay")
		} else {
			m.t.Errorf("Expected call to ScreenMock.CanDisplay with params: %#v", *m.CanDisplayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanDisplay != nil && mm_atomic.LoadUint64(&m.afterCanDisplayCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.CanDisplay")
	}
}

type mScreenMockCharacterSet struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockCharacterSetExpectation
	expectations       []*ScreenMockCharacterSetExpectation
}

// ScreenMockCharacterSetExpectation specifies expectation struct of the Screen.CharacterSet
type ScreenMockCharacterSetExpectation struct {
	mock *ScreenMock

	results *ScreenMockCharacterSetResults
	Counter uint64
}

// ScreenMockCharacterSetResults contains results of the Screen.CharacterSet
type ScreenMockCharacterSetResults struct {
	s1 string
}

// Expect sets up expected params for Screen.CharacterSet
func (mmCharacterSet *mScreenMockCharacterSet) Expect() *mScreenMockCharacterSet {
	if mmCharacterSet.mock.funcCharacterSet != nil {
		mmCharacterSet.mock.t.Fatalf("ScreenMock.CharacterSet mock is already set by Set")
	}

	if mmCharacterSet.defaultExpectation == nil {
		mmCharacterSet.defaultExpectation = &ScreenMockCharacterSetExpectation{}
	}

	return mmCharacterSet
}

// Inspect accepts an inspector function that has same arguments as the Screen.CharacterSet
func (mmCharacterSet *mScreenMockCharacterSet) Inspect(f func()) *mScreenMockCharacterSet {
	if mmCharacterSet.mock.inspectFuncCharacterSet != nil {
		mmCharacterSet.mock.t.Fatalf("Inspect function is already set for ScreenMock.CharacterSet")
	}

	mmCharacterSet.mock.inspectFuncCharacterSet = f

	return mmCharacterSet
}

// Return sets up results that will be returned by Screen.CharacterSet
func (mmCharacterSet *mScreenMockCharacterSet) Return(s1 string) *ScreenMock {
	if mmCharacterSet.mock.funcCharacterSet != nil {
		mmCharacterSet.mock.t.Fatalf("ScreenMock.CharacterSet mock is already set by Set")
	}

	if mmCharacterSet.defaultExpectation == nil {
		mmCharacterSet.defaultExpectation = &ScreenMockCharacterSetExpectation{mock: mmCharacterSet.mock}
	}
	mmCharacterSet.defaultExpectation.results = &ScreenMockCharacterSetResults{s1}
	return mmCharacterSet.mock
}

//Set uses given function f to mock the Screen.CharacterSet method
func (mmCharacterSet *mScreenMockCharacterSet) Set(f func() (s1 string)) *ScreenMock {
	if mmCharacterSet.defaultExpectation != nil {
		mmCharacterSet.mock.t.Fatalf("Default expectation is already set for the Screen.CharacterSet method")
	}

	if len(mmCharacterSet.expectations) > 0 {
		mmCharacterSet.mock.t.Fatalf("Some expectations are already set for the Screen.CharacterSet method")
	}

	mmCharacterSet.mock.funcCharacterSet = f
	return mmCharacterSet.mock
}

// CharacterSet implements tcell.Screen
func (mmCharacterSet *ScreenMock) CharacterSet() (s1 string) {
	mm_atomic.AddUint64(&mmCharacterSet.beforeCharacterSetCounter, 1)
	defer mm_atomic.AddUint64(&mmCharacterSet.afterCharacterSetCounter, 1)

	if mmCharacterSet.inspectFuncCharacterSet != nil {
		mmCharacterSet.inspectFuncCharacterSet()
	}

	if mmCharacterSet.CharacterSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCharacterSet.CharacterSetMock.defaultExpectation.Counter, 1)

		mm_results := mmCharacterSet.CharacterSetMock.defaultExpectation.results
		if mm_results == nil {
			mmCharacterSet.t.Fatal("No results are set for the ScreenMock.CharacterSet")
		}
		return (*mm_results).s1
	}
	if mmCharacterSet.funcCharacterSet != nil {
		return mmCharacterSet.funcCharacterSet()
	}
	mmCharacterSet.t.Fatalf("Unexpected call to ScreenMock.CharacterSet.")
	return
}

// CharacterSetAfterCounter returns a count of finished ScreenMock.CharacterSet invocations
func (mmCharacterSet *ScreenMock) CharacterSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCharacterSet.afterCharacterSetCounter)
}

// CharacterSetBeforeCounter returns a count of ScreenMock.CharacterSet invocations
func (mmCharacterSet *ScreenMock) CharacterSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCharacterSet.beforeCharacterSetCounter)
}

// MinimockCharacterSetDone returns true if the count of the CharacterSet invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockCharacterSetDone() bool {
	for _, e := range m.CharacterSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CharacterSetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCharacterSetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCharacterSet != nil && mm_atomic.LoadUint64(&m.afterCharacterSetCounter) < 1 {
		return false
	}
	return true
}

// MinimockCharacterSetInspect logs each unmet expectation
func (m *ScreenMock) MinimockCharacterSetInspect() {
	for _, e := range m.CharacterSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.CharacterSet")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CharacterSetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCharacterSetCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.CharacterSet")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCharacterSet != nil && mm_atomic.LoadUint64(&m.afterCharacterSetCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.CharacterSet")
	}
}

type mScreenMockClear struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockClearExpectation
	expectations       []*ScreenMockClearExpectation
}

// ScreenMockClearExpectation specifies expectation struct of the Screen.Clear
type ScreenMockClearExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.Clear
func (mmClear *mScreenMockClear) Expect() *mScreenMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("ScreenMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &ScreenMockClearExpectation{}
	}

	return mmClear
}

// Inspect accepts an inspector function that has same arguments as the Screen.Clear
func (mmClear *mScreenMockClear) Inspect(f func()) *mScreenMockClear {
	if mmClear.mock.inspectFuncClear != nil {
		mmClear.mock.t.Fatalf("Inspect function is already set for ScreenMock.Clear")
	}

	mmClear.mock.inspectFuncClear = f

	return mmClear
}

// Return sets up results that will be returned by Screen.Clear
func (mmClear *mScreenMockClear) Return() *ScreenMock {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("ScreenMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &ScreenMockClearExpectation{mock: mmClear.mock}
	}

	return mmClear.mock
}

//Set uses given function f to mock the Screen.Clear method
func (mmClear *mScreenMockClear) Set(f func()) *ScreenMock {
	if mmClear.defaultExpectation != nil {
		mmClear.mock.t.Fatalf("Default expectation is already set for the Screen.Clear method")
	}

	if len(mmClear.expectations) > 0 {
		mmClear.mock.t.Fatalf("Some expectations are already set for the Screen.Clear method")
	}

	mmClear.mock.funcClear = f
	return mmClear.mock
}

// Clear implements tcell.Screen
func (mmClear *ScreenMock) Clear() {
	mm_atomic.AddUint64(&mmClear.beforeClearCounter, 1)
	defer mm_atomic.AddUint64(&mmClear.afterClearCounter, 1)

	if mmClear.inspectFuncClear != nil {
		mmClear.inspectFuncClear()
	}

	if mmClear.ClearMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClear.ClearMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClear.funcClear != nil {
		mmClear.funcClear()
		return
	}
	mmClear.t.Fatalf("Unexpected call to ScreenMock.Clear.")

}

// ClearAfterCounter returns a count of finished ScreenMock.Clear invocations
func (mmClear *ScreenMock) ClearAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.afterClearCounter)
}

// ClearBeforeCounter returns a count of ScreenMock.Clear invocations
func (mmClear *ScreenMock) ClearBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.beforeClearCounter)
}

// MinimockClearDone returns true if the count of the Clear invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockClearDone() bool {
	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClear != nil && mm_atomic.LoadUint64(&m.afterClearCounter) < 1 {
		return false
	}
	return true
}

// MinimockClearInspect logs each unmet expectation
func (m *ScreenMock) MinimockClearInspect() {
	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.Clear")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Clear")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClear != nil && mm_atomic.LoadUint64(&m.afterClearCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Clear")
	}
}

type mScreenMockColors struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockColorsExpectation
	expectations       []*ScreenMockColorsExpectation
}

// ScreenMockColorsExpectation specifies expectation struct of the Screen.Colors
type ScreenMockColorsExpectation struct {
	mock *ScreenMock

	results *ScreenMockColorsResults
	Counter uint64
}

// ScreenMockColorsResults contains results of the Screen.Colors
type ScreenMockColorsResults struct {
	i1 int
}

// Expect sets up expected params for Screen.Colors
func (mmColors *mScreenMockColors) Expect() *mScreenMockColors {
	if mmColors.mock.funcColors != nil {
		mmColors.mock.t.Fatalf("ScreenMock.Colors mock is already set by Set")
	}

	if mmColors.defaultExpectation == nil {
		mmColors.defaultExpectation = &ScreenMockColorsExpectation{}
	}

	return mmColors
}

// Inspect accepts an inspector function that has same arguments as the Screen.Colors
func (mmColors *mScreenMockColors) Inspect(f func()) *mScreenMockColors {
	if mmColors.mock.inspectFuncColors != nil {
		mmColors.mock.t.Fatalf("Inspect function is already set for ScreenMock.Colors")
	}

	mmColors.mock.inspectFuncColors = f

	return mmColors
}

// Return sets up results that will be returned by Screen.Colors
func (mmColors *mScreenMockColors) Return(i1 int) *ScreenMock {
	if mmColors.mock.funcColors != nil {
		mmColors.mock.t.Fatalf("ScreenMock.Colors mock is already set by Set")
	}

	if mmColors.defaultExpectation == nil {
		mmColors.defaultExpectation = &ScreenMockColorsExpectation{mock: mmColors.mock}
	}
	mmColors.defaultExpectation.results = &ScreenMockColorsResults{i1}
	return mmColors.mock
}

//Set uses given function f to mock the Screen.Colors method
func (mmColors *mScreenMockColors) Set(f func() (i1 int)) *ScreenMock {
	if mmColors.defaultExpectation != nil {
		mmColors.mock.t.Fatalf("Default expectation is already set for the Screen.Colors method")
	}

	if len(mmColors.expectations) > 0 {
		mmColors.mock.t.Fatalf("Some expectations are already set for the Screen.Colors method")
	}

	mmColors.mock.funcColors = f
	return mmColors.mock
}

// Colors implements tcell.Screen
func (mmColors *ScreenMock) Colors() (i1 int) {
	mm_atomic.AddUint64(&mmColors.beforeColorsCounter, 1)
	defer mm_atomic.AddUint64(&mmColors.afterColorsCounter, 1)

	if mmColors.inspectFuncColors != nil {
		mmColors.inspectFuncColors()
	}

	if mmColors.ColorsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmColors.ColorsMock.defaultExpectation.Counter, 1)

		mm_results := mmColors.ColorsMock.defaultExpectation.results
		if mm_results == nil {
			mmColors.t.Fatal("No results are set for the ScreenMock.Colors")
		}
		return (*mm_results).i1
	}
	if mmColors.funcColors != nil {
		return mmColors.funcColors()
	}
	mmColors.t.Fatalf("Unexpected call to ScreenMock.Colors.")
	return
}

// ColorsAfterCounter returns a count of finished ScreenMock.Colors invocations
func (mmColors *ScreenMock) ColorsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmColors.afterColorsCounter)
}

// ColorsBeforeCounter returns a count of ScreenMock.Colors invocations
func (mmColors *ScreenMock) ColorsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmColors.beforeColorsCounter)
}

// MinimockColorsDone returns true if the count of the Colors invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockColorsDone() bool {
	for _, e := range m.ColorsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ColorsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterColorsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcColors != nil && mm_atomic.LoadUint64(&m.afterColorsCounter) < 1 {
		return false
	}
	return true
}

// MinimockColorsInspect logs each unmet expectation
func (m *ScreenMock) MinimockColorsInspect() {
	for _, e := range m.ColorsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.Colors")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ColorsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterColorsCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Colors")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcColors != nil && mm_atomic.LoadUint64(&m.afterColorsCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Colors")
	}
}

type mScreenMockDisableMouse struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockDisableMouseExpectation
	expectations       []*ScreenMockDisableMouseExpectation
}

// ScreenMockDisableMouseExpectation specifies expectation struct of the Screen.DisableMouse
type ScreenMockDisableMouseExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.DisableMouse
func (mmDisableMouse *mScreenMockDisableMouse) Expect() *mScreenMockDisableMouse {
	if mmDisableMouse.mock.funcDisableMouse != nil {
		mmDisableMouse.mock.t.Fatalf("ScreenMock.DisableMouse mock is already set by Set")
	}

	if mmDisableMouse.defaultExpectation == nil {
		mmDisableMouse.defaultExpectation = &ScreenMockDisableMouseExpectation{}
	}

	return mmDisableMouse
}

// Inspect accepts an inspector function that has same arguments as the Screen.DisableMouse
func (mmDisableMouse *mScreenMockDisableMouse) Inspect(f func()) *mScreenMockDisableMouse {
	if mmDisableMouse.mock.inspectFuncDisableMouse != nil {
		mmDisableMouse.mock.t.Fatalf("Inspect function is already set for ScreenMock.DisableMouse")
	}

	mmDisableMouse.mock.inspectFuncDisableMouse = f

	return mmDisableMouse
}

// Return sets up results that will be returned by Screen.DisableMouse
func (mmDisableMouse *mScreenMockDisableMouse) Return() *ScreenMock {
	if mmDisableMouse.mock.funcDisableMouse != nil {
		mmDisableMouse.mock.t.Fatalf("ScreenMock.DisableMouse mock is already set by Set")
	}

	if mmDisableMouse.defaultExpectation == nil {
		mmDisableMouse.defaultExpectation = &ScreenMockDisableMouseExpectation{mock: mmDisableMouse.mock}
	}

	return mmDisableMouse.mock
}

//Set uses given function f to mock the Screen.DisableMouse method
func (mmDisableMouse *mScreenMockDisableMouse) Set(f func()) *ScreenMock {
	if mmDisableMouse.defaultExpectation != nil {
		mmDisableMouse.mock.t.Fatalf("Default expectation is already set for the Screen.DisableMouse method")
	}

	if len(mmDisableMouse.expectations) > 0 {
		mmDisableMouse.mock.t.Fatalf("Some expectations are already set for the Screen.DisableMouse method")
	}

	mmDisableMouse.mock.funcDisableMouse = f
	return mmDisableMouse.mock
}

// DisableMouse implements tcell.Screen
func (mmDisableMouse *ScreenMock) DisableMouse() {
	mm_atomic.AddUint64(&mmDisableMouse.beforeDisableMouseCounter, 1)
	defer mm_atomic.AddUint64(&mmDisableMouse.afterDisableMouseCounter, 1)

	if mmDisableMouse.inspectFuncDisableMouse != nil {
		mmDisableMouse.inspectFuncDisableMouse()
	}

	if mmDisableMouse.DisableMouseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDisableMouse.DisableMouseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmDisableMouse.funcDisableMouse != nil {
		mmDisableMouse.funcDisableMouse()
		return
	}
	mmDisableMouse.t.Fatalf("Unexpected call to ScreenMock.DisableMouse.")

}

// DisableMouseAfterCounter returns a count of finished ScreenMock.DisableMouse invocations
func (mmDisableMouse *ScreenMock) DisableMouseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableMouse.afterDisableMouseCounter)
}

// DisableMouseBeforeCounter returns a count of ScreenMock.DisableMouse invocations
func (mmDisableMouse *ScreenMock) DisableMouseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisableMouse.beforeDisableMouseCounter)
}

// MinimockDisableMouseDone returns true if the count of the DisableMouse invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockDisableMouseDone() bool {
	for _, e := range m.DisableMouseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DisableMouseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDisableMouseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDisableMouse != nil && mm_atomic.LoadUint64(&m.afterDisableMouseCounter) < 1 {
		return false
	}
	return true
}

// MinimockDisableMouseInspect logs each unmet expectation
func (m *ScreenMock) MinimockDisableMouseInspect() {
	for _, e := range m.DisableMouseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.DisableMouse")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DisableMouseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDisableMouseCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.DisableMouse")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDisableMouse != nil && mm_atomic.LoadUint64(&m.afterDisableMouseCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.DisableMouse")
	}
}

type mScreenMockDisablePaste struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockDisablePasteExpectation
	expectations       []*ScreenMockDisablePasteExpectation
}

// ScreenMockDisablePasteExpectation specifies expectation struct of the Screen.DisablePaste
type ScreenMockDisablePasteExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.DisablePaste
func (mmDisablePaste *mScreenMockDisablePaste) Expect() *mScreenMockDisablePaste {
	if mmDisablePaste.mock.funcDisablePaste != nil {
		mmDisablePaste.mock.t.Fatalf("ScreenMock.DisablePaste mock is already set by Set")
	}

	if mmDisablePaste.defaultExpectation == nil {
		mmDisablePaste.defaultExpectation = &ScreenMockDisablePasteExpectation{}
	}

	return mmDisablePaste
}

// Inspect accepts an inspector function that has same arguments as the Screen.DisablePaste
func (mmDisablePaste *mScreenMockDisablePaste) Inspect(f func()) *mScreenMockDisablePaste {
	if mmDisablePaste.mock.inspectFuncDisablePaste != nil {
		mmDisablePaste.mock.t.Fatalf("Inspect function is already set for ScreenMock.DisablePaste")
	}

	mmDisablePaste.mock.inspectFuncDisablePaste = f

	return mmDisablePaste
}

// Return sets up results that will be returned by Screen.DisablePaste
func (mmDisablePaste *mScreenMockDisablePaste) Return() *ScreenMock {
	if mmDisablePaste.mock.funcDisablePaste != nil {
		mmDisablePaste.mock.t.Fatalf("ScreenMock.DisablePaste mock is already set by Set")
	}

	if mmDisablePaste.defaultExpectation == nil {
		mmDisablePaste.defaultExpectation = &ScreenMockDisablePasteExpectation{mock: mmDisablePaste.mock}
	}

	return mmDisablePaste.mock
}

//Set uses given function f to mock the Screen.DisablePaste method
func (mmDisablePaste *mScreenMockDisablePaste) Set(f func()) *ScreenMock {
	if mmDisablePaste.defaultExpectation != nil {
		mmDisablePaste.mock.t.Fatalf("Default expectation is already set for the Screen.DisablePaste method")
	}

	if len(mmDisablePaste.expectations) > 0 {
		mmDisablePaste.mock.t.Fatalf("Some expectations are already set for the Screen.DisablePaste method")
	}

	mmDisablePaste.mock.funcDisablePaste = f
	return mmDisablePaste.mock
}

// DisablePaste implements tcell.Screen
func (mmDisablePaste *ScreenMock) DisablePaste() {
	mm_atomic.AddUint64(&mmDisablePaste.beforeDisablePasteCounter, 1)
	defer mm_atomic.AddUint64(&mmDisablePaste.afterDisablePasteCounter, 1)

	if mmDisablePaste.inspectFuncDisablePaste != nil {
		mmDisablePaste.inspectFuncDisablePaste()
	}

	if mmDisablePaste.DisablePasteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDisablePaste.DisablePasteMock.defaultExpectation.Counter, 1)

		return

	}
	if mmDisablePaste.funcDisablePaste != nil {
		mmDisablePaste.funcDisablePaste()
		return
	}
	mmDisablePaste.t.Fatalf("Unexpected call to ScreenMock.DisablePaste.")

}

// DisablePasteAfterCounter returns a count of finished ScreenMock.DisablePaste invocations
func (mmDisablePaste *ScreenMock) DisablePasteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisablePaste.afterDisablePasteCounter)
}

// DisablePasteBeforeCounter returns a count of ScreenMock.DisablePaste invocations
func (mmDisablePaste *ScreenMock) DisablePasteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDisablePaste.beforeDisablePasteCounter)
}

// MinimockDisablePasteDone returns true if the count of the DisablePaste invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockDisablePasteDone() bool {
	for _, e := range m.DisablePasteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DisablePasteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDisablePasteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDisablePaste != nil && mm_atomic.LoadUint64(&m.afterDisablePasteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDisablePasteInspect logs each unmet expectation
func (m *ScreenMock) MinimockDisablePasteInspect() {
	for _, e := range m.DisablePasteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.DisablePaste")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DisablePasteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDisablePasteCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.DisablePaste")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDisablePaste != nil && mm_atomic.LoadUint64(&m.afterDisablePasteCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.DisablePaste")
	}
}

type mScreenMockEnableMouse struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockEnableMouseExpectation
	expectations       []*ScreenMockEnableMouseExpectation
}

// ScreenMockEnableMouseExpectation specifies expectation struct of the Screen.EnableMouse
type ScreenMockEnableMouseExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.EnableMouse
func (mmEnableMouse *mScreenMockEnableMouse) Expect() *mScreenMockEnableMouse {
	if mmEnableMouse.mock.funcEnableMouse != nil {
		mmEnableMouse.mock.t.Fatalf("ScreenMock.EnableMouse mock is already set by Set")
	}

	if mmEnableMouse.defaultExpectation == nil {
		mmEnableMouse.defaultExpectation = &ScreenMockEnableMouseExpectation{}
	}

	return mmEnableMouse
}

// Inspect accepts an inspector function that has same arguments as the Screen.EnableMouse
func (mmEnableMouse *mScreenMockEnableMouse) Inspect(f func()) *mScreenMockEnableMouse {
	if mmEnableMouse.mock.inspectFuncEnableMouse != nil {
		mmEnableMouse.mock.t.Fatalf("Inspect function is already set for ScreenMock.EnableMouse")
	}

	mmEnableMouse.mock.inspectFuncEnableMouse = f

	return mmEnableMouse
}

// Return sets up results that will be returned by Screen.EnableMouse
func (mmEnableMouse *mScreenMockEnableMouse) Return() *ScreenMock {
	if mmEnableMouse.mock.funcEnableMouse != nil {
		mmEnableMouse.mock.t.Fatalf("ScreenMock.EnableMouse mock is already set by Set")
	}

	if mmEnableMouse.defaultExpectation == nil {
		mmEnableMouse.defaultExpectation = &ScreenMockEnableMouseExpectation{mock: mmEnableMouse.mock}
	}

	return mmEnableMouse.mock
}

//Set uses given function f to mock the Screen.EnableMouse method
func (mmEnableMouse *mScreenMockEnableMouse) Set(f func()) *ScreenMock {
	if mmEnableMouse.defaultExpectation != nil {
		mmEnableMouse.mock.t.Fatalf("Default expectation is already set for the Screen.EnableMouse method")
	}

	if len(mmEnableMouse.expectations) > 0 {
		mmEnableMouse.mock.t.Fatalf("Some expectations are already set for the Screen.EnableMouse method")
	}

	mmEnableMouse.mock.funcEnableMouse = f
	return mmEnableMouse.mock
}

// EnableMouse implements tcell.Screen
func (mmEnableMouse *ScreenMock) EnableMouse() {
	mm_atomic.AddUint64(&mmEnableMouse.beforeEnableMouseCounter, 1)
	defer mm_atomic.AddUint64(&mmEnableMouse.afterEnableMouseCounter, 1)

	if mmEnableMouse.inspectFuncEnableMouse != nil {
		mmEnableMouse.inspectFuncEnableMouse()
	}

	if mmEnableMouse.EnableMouseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnableMouse.EnableMouseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmEnableMouse.funcEnableMouse != nil {
		mmEnableMouse.funcEnableMouse()
		return
	}
	mmEnableMouse.t.Fatalf("Unexpected call to ScreenMock.EnableMouse.")

}

// EnableMouseAfterCounter returns a count of finished ScreenMock.EnableMouse invocations
func (mmEnableMouse *ScreenMock) EnableMouseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnableMouse.afterEnableMouseCounter)
}

// EnableMouseBeforeCounter returns a count of ScreenMock.EnableMouse invocations
func (mmEnableMouse *ScreenMock) EnableMouseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnableMouse.beforeEnableMouseCounter)
}

// MinimockEnableMouseDone returns true if the count of the EnableMouse invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockEnableMouseDone() bool {
	for _, e := range m.EnableMouseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnableMouseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnableMouseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnableMouse != nil && mm_atomic.LoadUint64(&m.afterEnableMouseCounter) < 1 {
		return false
	}
	return true
}

// MinimockEnableMouseInspect logs each unmet expectation
func (m *ScreenMock) MinimockEnableMouseInspect() {
	for _, e := range m.EnableMouseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.EnableMouse")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnableMouseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnableMouseCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.EnableMouse")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnableMouse != nil && mm_atomic.LoadUint64(&m.afterEnableMouseCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.EnableMouse")
	}
}

type mScreenMockEnablePaste struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockEnablePasteExpectation
	expectations       []*ScreenMockEnablePasteExpectation
}

// ScreenMockEnablePasteExpectation specifies expectation struct of the Screen.EnablePaste
type ScreenMockEnablePasteExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.EnablePaste
func (mmEnablePaste *mScreenMockEnablePaste) Expect() *mScreenMockEnablePaste {
	if mmEnablePaste.mock.funcEnablePaste != nil {
		mmEnablePaste.mock.t.Fatalf("ScreenMock.EnablePaste mock is already set by Set")
	}

	if mmEnablePaste.defaultExpectation == nil {
		mmEnablePaste.defaultExpectation = &ScreenMockEnablePasteExpectation{}
	}

	return mmEnablePaste
}

// Inspect accepts an inspector function that has same arguments as the Screen.EnablePaste
func (mmEnablePaste *mScreenMockEnablePaste) Inspect(f func()) *mScreenMockEnablePaste {
	if mmEnablePaste.mock.inspectFuncEnablePaste != nil {
		mmEnablePaste.mock.t.Fatalf("Inspect function is already set for ScreenMock.EnablePaste")
	}

	mmEnablePaste.mock.inspectFuncEnablePaste = f

	return mmEnablePaste
}

// Return sets up results that will be returned by Screen.EnablePaste
func (mmEnablePaste *mScreenMockEnablePaste) Return() *ScreenMock {
	if mmEnablePaste.mock.funcEnablePaste != nil {
		mmEnablePaste.mock.t.Fatalf("ScreenMock.EnablePaste mock is already set by Set")
	}

	if mmEnablePaste.defaultExpectation == nil {
		mmEnablePaste.defaultExpectation = &ScreenMockEnablePasteExpectation{mock: mmEnablePaste.mock}
	}

	return mmEnablePaste.mock
}

//Set uses given function f to mock the Screen.EnablePaste method
func (mmEnablePaste *mScreenMockEnablePaste) Set(f func()) *ScreenMock {
	if mmEnablePaste.defaultExpectation != nil {
		mmEnablePaste.mock.t.Fatalf("Default expectation is already set for the Screen.EnablePaste method")
	}

	if len(mmEnablePaste.expectations) > 0 {
		mmEnablePaste.mock.t.Fatalf("Some expectations are already set for the Screen.EnablePaste method")
	}

	mmEnablePaste.mock.funcEnablePaste = f
	return mmEnablePaste.mock
}

// EnablePaste implements tcell.Screen
func (mmEnablePaste *ScreenMock) EnablePaste() {
	mm_atomic.AddUint64(&mmEnablePaste.beforeEnablePasteCounter, 1)
	defer mm_atomic.AddUint64(&mmEnablePaste.afterEnablePasteCounter, 1)

	if mmEnablePaste.inspectFuncEnablePaste != nil {
		mmEnablePaste.inspectFuncEnablePaste()
	}

	if mmEnablePaste.EnablePasteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnablePaste.EnablePasteMock.defaultExpectation.Counter, 1)

		return

	}
	if mmEnablePaste.funcEnablePaste != nil {
		mmEnablePaste.funcEnablePaste()
		return
	}
	mmEnablePaste.t.Fatalf("Unexpected call to ScreenMock.EnablePaste.")

}

// EnablePasteAfterCounter returns a count of finished ScreenMock.EnablePaste invocations
func (mmEnablePaste *ScreenMock) EnablePasteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnablePaste.afterEnablePasteCounter)
}

// EnablePasteBeforeCounter returns a count of ScreenMock.EnablePaste invocations
func (mmEnablePaste *ScreenMock) EnablePasteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnablePaste.beforeEnablePasteCounter)
}

// MinimockEnablePasteDone returns true if the count of the EnablePaste invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockEnablePasteDone() bool {
	for _, e := range m.EnablePasteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnablePasteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnablePasteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnablePaste != nil && mm_atomic.LoadUint64(&m.afterEnablePasteCounter) < 1 {
		return false
	}
	return true
}

// MinimockEnablePasteInspect logs each unmet expectation
func (m *ScreenMock) MinimockEnablePasteInspect() {
	for _, e := range m.EnablePasteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.EnablePaste")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnablePasteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnablePasteCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.EnablePaste")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnablePaste != nil && mm_atomic.LoadUint64(&m.afterEnablePasteCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.EnablePaste")
	}
}

type mScreenMockFill struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockFillExpectation
	expectations       []*ScreenMockFillExpectation

	callArgs []*ScreenMockFillParams
	mutex    sync.RWMutex
}

// ScreenMockFillExpectation specifies expectation struct of the Screen.Fill
type ScreenMockFillExpectation struct {
	mock   *ScreenMock
	params *ScreenMockFillParams

	Counter uint64
}

// ScreenMockFillParams contains parameters of the Screen.Fill
type ScreenMockFillParams struct {
	r1 rune
	s1 mm_tcell.Style
}

// Expect sets up expected params for Screen.Fill
func (mmFill *mScreenMockFill) Expect(r1 rune, s1 mm_tcell.Style) *mScreenMockFill {
	if mmFill.mock.funcFill != nil {
		mmFill.mock.t.Fatalf("ScreenMock.Fill mock is already set by Set")
	}

	if mmFill.defaultExpectation == nil {
		mmFill.defaultExpectation = &ScreenMockFillExpectation{}
	}

	mmFill.defaultExpectation.params = &ScreenMockFillParams{r1, s1}
	for _, e := range mmFill.expectations {
		if minimock.Equal(e.params, mmFill.defaultExpectation.params) {
			mmFill.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFill.defaultExpectation.params)
		}
	}

	return mmFill
}

// Inspect accepts an inspector function that has same arguments as the Screen.Fill
func (mmFill *mScreenMockFill) Inspect(f func(r1 rune, s1 mm_tcell.Style)) *mScreenMockFill {
	if mmFill.mock.inspectFuncFill != nil {
		mmFill.mock.t.Fatalf("Inspect function is already set for ScreenMock.Fill")
	}

	mmFill.mock.inspectFuncFill = f

	return mmFill
}

// Return sets up results that will be returned by Screen.Fill
func (mmFill *mScreenMockFill) Return() *ScreenMock {
	if mmFill.mock.funcFill != nil {
		mmFill.mock.t.Fatalf("ScreenMock.Fill mock is already set by Set")
	}

	if mmFill.defaultExpectation == nil {
		mmFill.defaultExpectation = &ScreenMockFillExpectation{mock: mmFill.mock}
	}

	return mmFill.mock
}

//Set uses given function f to mock the Screen.Fill method
func (mmFill *mScreenMockFill) Set(f func(r1 rune, s1 mm_tcell.Style)) *ScreenMock {
	if mmFill.defaultExpectation != nil {
		mmFill.mock.t.Fatalf("Default expectation is already set for the Screen.Fill method")
	}

	if len(mmFill.expectations) > 0 {
		mmFill.mock.t.Fatalf("Some expectations are already set for the Screen.Fill method")
	}

	mmFill.mock.funcFill = f
	return mmFill.mock
}

// Fill implements tcell.Screen
func (mmFill *ScreenMock) Fill(r1 rune, s1 mm_tcell.Style) {
	mm_atomic.AddUint64(&mmFill.beforeFillCounter, 1)
	defer mm_atomic.AddUint64(&mmFill.afterFillCounter, 1)

	if mmFill.inspectFuncFill != nil {
		mmFill.inspectFuncFill(r1, s1)
	}

	mm_params := &ScreenMockFillParams{r1, s1}

	// Record call args
	mmFill.FillMock.mutex.Lock()
	mmFill.FillMock.callArgs = append(mmFill.FillMock.callArgs, mm_params)
	mmFill.FillMock.mutex.Unlock()

	for _, e := range mmFill.FillMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFill.FillMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFill.FillMock.defaultExpectation.Counter, 1)
		mm_want := mmFill.FillMock.defaultExpectation.params
		mm_got := ScreenMockFillParams{r1, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFill.t.Errorf("ScreenMock.Fill got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFill.funcFill != nil {
		mmFill.funcFill(r1, s1)
		return
	}
	mmFill.t.Fatalf("Unexpected call to ScreenMock.Fill. %v %v", r1, s1)

}

// FillAfterCounter returns a count of finished ScreenMock.Fill invocations
func (mmFill *ScreenMock) FillAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFill.afterFillCounter)
}

// FillBeforeCounter returns a count of ScreenMock.Fill invocations
func (mmFill *ScreenMock) FillBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFill.beforeFillCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.Fill.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFill *mScreenMockFill) Calls() []*ScreenMockFillParams {
	mmFill.mutex.RLock()

	argCopy := make([]*ScreenMockFillParams, len(mmFill.callArgs))
	copy(argCopy, mmFill.callArgs)

	mmFill.mutex.RUnlock()

	return argCopy
}

// MinimockFillDone returns true if the count of the Fill invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockFillDone() bool {
	for _, e := range m.FillMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FillMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFillCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFill != nil && mm_atomic.LoadUint64(&m.afterFillCounter) < 1 {
		return false
	}
	return true
}

// MinimockFillInspect logs each unmet expectation
func (m *ScreenMock) MinimockFillInspect() {
	for _, e := range m.FillMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.Fill with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FillMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFillCounter) < 1 {
		if m.FillMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.Fill")
		} else {
			m.t.Errorf("Expected call to ScreenMock.Fill with params: %#v", *m.FillMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFill != nil && mm_atomic.LoadUint64(&m.afterFillCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Fill")
	}
}

type mScreenMockFini struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockFiniExpectation
	expectations       []*ScreenMockFiniExpectation
}

// ScreenMockFiniExpectation specifies expectation struct of the Screen.Fini
type ScreenMockFiniExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.Fini
func (mmFini *mScreenMockFini) Expect() *mScreenMockFini {
	if mmFini.mock.funcFini != nil {
		mmFini.mock.t.Fatalf("ScreenMock.Fini mock is already set by Set")
	}

	if mmFini.defaultExpectation == nil {
		mmFini.defaultExpectation = &ScreenMockFiniExpectation{}
	}

	return mmFini
}

// Inspect accepts an inspector function that has same arguments as the Screen.Fini
func (mmFini *mScreenMockFini) Inspect(f func()) *mScreenMockFini {
	if mmFini.mock.inspectFuncFini != nil {
		mmFini.mock.t.Fatalf("Inspect function is already set for ScreenMock.Fini")
	}

	mmFini.mock.inspectFuncFini = f

	return mmFini
}

// Return sets up results that will be returned by Screen.Fini
func (mmFini *mScreenMockFini) Return() *ScreenMock {
	if mmFini.mock.funcFini != nil {
		mmFini.mock.t.Fatalf("ScreenMock.Fini mock is already set by Set")
	}

	if mmFini.defaultExpectation == nil {
		mmFini.defaultExpectation = &ScreenMockFiniExpectation{mock: mmFini.mock}
	}

	return mmFini.mock
}

//Set uses given function f to mock the Screen.Fini method
func (mmFini *mScreenMockFini) Set(f func()) *ScreenMock {
	if mmFini.defaultExpectation != nil {
		mmFini.mock.t.Fatalf("Default expectation is already set for the Screen.Fini method")
	}

	if len(mmFini.expectations) > 0 {
		mmFini.mock.t.Fatalf("Some expectations are already set for the Screen.Fini method")
	}

	mmFini.mock.funcFini = f
	return mmFini.mock
}

// Fini implements tcell.Screen
func (mmFini *ScreenMock) Fini() {
	mm_atomic.AddUint64(&mmFini.beforeFiniCounter, 1)
	defer mm_atomic.AddUint64(&mmFini.afterFiniCounter, 1)

	if mmFini.inspectFuncFini != nil {
		mmFini.inspectFuncFini()
	}

	if mmFini.FiniMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFini.FiniMock.defaultExpectation.Counter, 1)

		return

	}
	if mmFini.funcFini != nil {
		mmFini.funcFini()
		return
	}
	mmFini.t.Fatalf("Unexpected call to ScreenMock.Fini.")

}

// FiniAfterCounter returns a count of finished ScreenMock.Fini invocations
func (mmFini *ScreenMock) FiniAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFini.afterFiniCounter)
}

// FiniBeforeCounter returns a count of ScreenMock.Fini invocations
func (mmFini *ScreenMock) FiniBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFini.beforeFiniCounter)
}

// MinimockFiniDone returns true if the count of the Fini invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockFiniDone() bool {
	for _, e := range m.FiniMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FiniMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFiniCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFini != nil && mm_atomic.LoadUint64(&m.afterFiniCounter) < 1 {
		return false
	}
	return true
}

// MinimockFiniInspect logs each unmet expectation
func (m *ScreenMock) MinimockFiniInspect() {
	for _, e := range m.FiniMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.Fini")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FiniMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFiniCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Fini")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFini != nil && mm_atomic.LoadUint64(&m.afterFiniCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Fini")
	}
}

type mScreenMockGetContent struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockGetContentExpectation
	expectations       []*ScreenMockGetContentExpectation

	callArgs []*ScreenMockGetContentParams
	mutex    sync.RWMutex
}

// ScreenMockGetContentExpectation specifies expectation struct of the Screen.GetContent
type ScreenMockGetContentExpectation struct {
	mock    *ScreenMock
	params  *ScreenMockGetContentParams
	results *ScreenMockGetContentResults
	Counter uint64
}

// ScreenMockGetContentParams contains parameters of the Screen.GetContent
type ScreenMockGetContentParams struct {
	x int
	y int
}

// ScreenMockGetContentResults contains results of the Screen.GetContent
type ScreenMockGetContentResults struct {
	mainc rune
	combc []rune
	style mm_tcell.Style
	width int
}

// Expect sets up expected params for Screen.GetContent
func (mmGetContent *mScreenMockGetContent) Expect(x int, y int) *mScreenMockGetContent {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("ScreenMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &ScreenMockGetContentExpectation{}
	}

	mmGetContent.defaultExpectation.params = &ScreenMockGetContentParams{x, y}
	for _, e := range mmGetContent.expectations {
		if minimock.Equal(e.params, mmGetContent.defaultExpectation.params) {
			mmGetContent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetContent.defaultExpectation.params)
		}
	}

	return mmGetContent
}

// Inspect accepts an inspector function that has same arguments as the Screen.GetContent
func (mmGetContent *mScreenMockGetContent) Inspect(f func(x int, y int)) *mScreenMockGetContent {
	if mmGetContent.mock.inspectFuncGetContent != nil {
		mmGetContent.mock.t.Fatalf("Inspect function is already set for ScreenMock.GetContent")
	}

	mmGetContent.mock.inspectFuncGetContent = f

	return mmGetContent
}

// Return sets up results that will be returned by Screen.GetContent
func (mmGetContent *mScreenMockGetContent) Return(mainc rune, combc []rune, style mm_tcell.Style, width int) *ScreenMock {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("ScreenMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &ScreenMockGetContentExpectation{mock: mmGetContent.mock}
	}
	mmGetContent.defaultExpectation.results = &ScreenMockGetContentResults{mainc, combc, style, width}
	return mmGetContent.mock
}

//Set uses given function f to mock the Screen.GetContent method
func (mmGetContent *mScreenMockGetContent) Set(f func(x int, y int) (mainc rune, combc []rune, style mm_tcell.Style, width int)) *ScreenMock {
	if mmGetContent.defaultExpectation != nil {
		mmGetContent.mock.t.Fatalf("Default expectation is already set for the Screen.GetContent method")
	}

	if len(mmGetContent.expectations) > 0 {
		mmGetContent.mock.t.Fatalf("Some expectations are already set for the Screen.GetContent method")
	}

	mmGetContent.mock.funcGetContent = f
	return mmGetContent.mock
}

// When sets expectation for the Screen.GetContent which will trigger the result defined by the following
// Then helper
func (mmGetContent *mScreenMockGetContent) When(x int, y int) *ScreenMockGetContentExpectation {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("ScreenMock.GetContent mock is already set by Set")
	}

	expectation := &ScreenMockGetContentExpectation{
		mock:   mmGetContent.mock,
		params: &ScreenMockGetContentParams{x, y},
	}
	mmGetContent.expectations = append(mmGetContent.expectations, expectation)
	return expectation
}

// Then sets up Screen.GetContent return parameters for the expectation previously defined by the When method
func (e *ScreenMockGetContentExpectation) Then(mainc rune, combc []rune, style mm_tcell.Style, width int) *ScreenMock {
	e.results = &ScreenMockGetContentResults{mainc, combc, style, width}
	return e.mock
}

// GetContent implements tcell.Screen
func (mmGetContent *ScreenMock) GetContent(x int, y int) (mainc rune, combc []rune, style mm_tcell.Style, width int) {
	mm_atomic.AddUint64(&mmGetContent.beforeGetContentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContent.afterGetContentCounter, 1)

	if mmGetContent.inspectFuncGetContent != nil {
		mmGetContent.inspectFuncGetContent(x, y)
	}

	mm_params := &ScreenMockGetContentParams{x, y}

	// Record call args
	mmGetContent.GetContentMock.mutex.Lock()
	mmGetContent.GetContentMock.callArgs = append(mmGetContent.GetContentMock.callArgs, mm_params)
	mmGetContent.GetContentMock.mutex.Unlock()

	for _, e := range mmGetContent.GetContentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mainc, e.results.combc, e.results.style, e.results.width
		}
	}

	if mmGetContent.GetContentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContent.GetContentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetContent.GetContentMock.defaultExpectation.params
		mm_got := ScreenMockGetContentParams{x, y}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetContent.t.Errorf("ScreenMock.GetContent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetContent.GetContentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContent.t.Fatal("No results are set for the ScreenMock.GetContent")
		}
		return (*mm_results).mainc, (*mm_results).combc, (*mm_results).style, (*mm_results).width
	}
	if mmGetContent.funcGetContent != nil {
		return mmGetContent.funcGetContent(x, y)
	}
	mmGetContent.t.Fatalf("Unexpected call to ScreenMock.GetContent. %v %v", x, y)
	return
}

// GetContentAfterCounter returns a count of finished ScreenMock.GetContent invocations
func (mmGetContent *ScreenMock) GetContentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContent.afterGetContentCounter)
}

// GetContentBeforeCounter returns a count of ScreenMock.GetContent invocations
func (mmGetContent *ScreenMock) GetContentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContent.beforeGetContentCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.GetContent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetContent *mScreenMockGetContent) Calls() []*ScreenMockGetContentParams {
	mmGetContent.mutex.RLock()

	argCopy := make([]*ScreenMockGetContentParams, len(mmGetContent.callArgs))
	copy(argCopy, mmGetContent.callArgs)

	mmGetContent.mutex.RUnlock()

	return argCopy
}

// MinimockGetContentDone returns true if the count of the GetContent invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockGetContentDone() bool {
	for _, e := range m.GetContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContent != nil && mm_atomic.LoadUint64(&m.afterGetContentCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetContentInspect logs each unmet expectation
func (m *ScreenMock) MinimockGetContentInspect() {
	for _, e := range m.GetContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.GetContent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetContentCounter) < 1 {
		if m.GetContentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.GetContent")
		} else {
			m.t.Errorf("Expected call to ScreenMock.GetContent with params: %#v", *m.GetContentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContent != nil && mm_atomic.LoadUint64(&m.afterGetContentCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.GetContent")
	}
}

type mScreenMockHasKey struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockHasKeyExpectation
	expectations       []*ScreenMockHasKeyExpectation

	callArgs []*ScreenMockHasKeyParams
	mutex    sync.RWMutex
}

// ScreenMockHasKeyExpectation specifies expectation struct of the Screen.HasKey
type ScreenMockHasKeyExpectation struct {
	mock    *ScreenMock
	params  *ScreenMockHasKeyParams
	results *ScreenMockHasKeyResults
	Counter uint64
}

// ScreenMockHasKeyParams contains parameters of the Screen.HasKey
type ScreenMockHasKeyParams struct {
	k1 mm_tcell.Key
}

// ScreenMockHasKeyResults contains results of the Screen.HasKey
type ScreenMockHasKeyResults struct {
	b1 bool
}

// Expect sets up expected params for Screen.HasKey
func (mmHasKey *mScreenMockHasKey) Expect(k1 mm_tcell.Key) *mScreenMockHasKey {
	if mmHasKey.mock.funcHasKey != nil {
		mmHasKey.mock.t.Fatalf("ScreenMock.HasKey mock is already set by Set")
	}

	if mmHasKey.defaultExpectation == nil {
		mmHasKey.defaultExpectation = &ScreenMockHasKeyExpectation{}
	}

	mmHasKey.defaultExpectation.params = &ScreenMockHasKeyParams{k1}
	for _, e := range mmHasKey.expectations {
		if minimock.Equal(e.params, mmHasKey.defaultExpectation.params) {
			mmHasKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHasKey.defaultExpectation.params)
		}
	}

	return mmHasKey
}

// Inspect accepts an inspector function that has same arguments as the Screen.HasKey
func (mmHasKey *mScreenMockHasKey) Inspect(f func(k1 mm_tcell.Key)) *mScreenMockHasKey {
	if mmHasKey.mock.inspectFuncHasKey != nil {
		mmHasKey.mock.t.Fatalf("Inspect function is already set for ScreenMock.HasKey")
	}

	mmHasKey.mock.inspectFuncHasKey = f

	return mmHasKey
}

// Return sets up results that will be returned by Screen.HasKey
func (mmHasKey *mScreenMockHasKey) Return(b1 bool) *ScreenMock {
	if mmHasKey.mock.funcHasKey != nil {
		mmHasKey.mock.t.Fatalf("ScreenMock.HasKey mock is already set by Set")
	}

	if mmHasKey.defaultExpectation == nil {
		mmHasKey.defaultExpectation = &ScreenMockHasKeyExpectation{mock: mmHasKey.mock}
	}
	mmHasKey.defaultExpectation.results = &ScreenMockHasKeyResults{b1}
	return mmHasKey.mock
}

//Set uses given function f to mock the Screen.HasKey method
func (mmHasKey *mScreenMockHasKey) Set(f func(k1 mm_tcell.Key) (b1 bool)) *ScreenMock {
	if mmHasKey.defaultExpectation != nil {
		mmHasKey.mock.t.Fatalf("Default expectation is already set for the Screen.HasKey method")
	}

	if len(mmHasKey.expectations) > 0 {
		mmHasKey.mock.t.Fatalf("Some expectations are already set for the Screen.HasKey method")
	}

	mmHasKey.mock.funcHasKey = f
	return mmHasKey.mock
}

// When sets expectation for the Screen.HasKey which will trigger the result defined by the following
// Then helper
func (mmHasKey *mScreenMockHasKey) When(k1 mm_tcell.Key) *ScreenMockHasKeyExpectation {
	if mmHasKey.mock.funcHasKey != nil {
		mmHasKey.mock.t.Fatalf("ScreenMock.HasKey mock is already set by Set")
	}

	expectation := &ScreenMockHasKeyExpectation{
		mock:   mmHasKey.mock,
		params: &ScreenMockHasKeyParams{k1},
	}
	mmHasKey.expectations = append(mmHasKey.expectations, expectation)
	return expectation
}

// Then sets up Screen.HasKey return parameters for the expectation previously defined by the When method
func (e *ScreenMockHasKeyExpectation) Then(b1 bool) *ScreenMock {
	e.results = &ScreenMockHasKeyResults{b1}
	return e.mock
}

// HasKey implements tcell.Screen
func (mmHasKey *ScreenMock) HasKey(k1 mm_tcell.Key) (b1 bool) {
	mm_atomic.AddUint64(&mmHasKey.beforeHasKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmHasKey.afterHasKeyCounter, 1)

	if mmHasKey.inspectFuncHasKey != nil {
		mmHasKey.inspectFuncHasKey(k1)
	}

	mm_params := &ScreenMockHasKeyParams{k1}

	// Record call args
	mmHasKey.HasKeyMock.mutex.Lock()
	mmHasKey.HasKeyMock.callArgs = append(mmHasKey.HasKeyMock.callArgs, mm_params)
	mmHasKey.HasKeyMock.mutex.Unlock()

	for _, e := range mmHasKey.HasKeyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmHasKey.HasKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasKey.HasKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmHasKey.HasKeyMock.defaultExpectation.params
		mm_got := ScreenMockHasKeyParams{k1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHasKey.t.Errorf("ScreenMock.HasKey got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHasKey.HasKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmHasKey.t.Fatal("No results are set for the ScreenMock.HasKey")
		}
		return (*mm_results).b1
	}
	if mmHasKey.funcHasKey != nil {
		return mmHasKey.funcHasKey(k1)
	}
	mmHasKey.t.Fatalf("Unexpected call to ScreenMock.HasKey. %v", k1)
	return
}

// HasKeyAfterCounter returns a count of finished ScreenMock.HasKey invocations
func (mmHasKey *ScreenMock) HasKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasKey.afterHasKeyCounter)
}

// HasKeyBeforeCounter returns a count of ScreenMock.HasKey invocations
func (mmHasKey *ScreenMock) HasKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasKey.beforeHasKeyCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.HasKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHasKey *mScreenMockHasKey) Calls() []*ScreenMockHasKeyParams {
	mmHasKey.mutex.RLock()

	argCopy := make([]*ScreenMockHasKeyParams, len(mmHasKey.callArgs))
	copy(argCopy, mmHasKey.callArgs)

	mmHasKey.mutex.RUnlock()

	return argCopy
}

// MinimockHasKeyDone returns true if the count of the HasKey invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockHasKeyDone() bool {
	for _, e := range m.HasKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasKeyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasKey != nil && mm_atomic.LoadUint64(&m.afterHasKeyCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasKeyInspect logs each unmet expectation
func (m *ScreenMock) MinimockHasKeyInspect() {
	for _, e := range m.HasKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.HasKey with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasKeyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasKeyCounter) < 1 {
		if m.HasKeyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.HasKey")
		} else {
			m.t.Errorf("Expected call to ScreenMock.HasKey with params: %#v", *m.HasKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasKey != nil && mm_atomic.LoadUint64(&m.afterHasKeyCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.HasKey")
	}
}

type mScreenMockHasMouse struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockHasMouseExpectation
	expectations       []*ScreenMockHasMouseExpectation
}

// ScreenMockHasMouseExpectation specifies expectation struct of the Screen.HasMouse
type ScreenMockHasMouseExpectation struct {
	mock *ScreenMock

	results *ScreenMockHasMouseResults
	Counter uint64
}

// ScreenMockHasMouseResults contains results of the Screen.HasMouse
type ScreenMockHasMouseResults struct {
	b1 bool
}

// Expect sets up expected params for Screen.HasMouse
func (mmHasMouse *mScreenMockHasMouse) Expect() *mScreenMockHasMouse {
	if mmHasMouse.mock.funcHasMouse != nil {
		mmHasMouse.mock.t.Fatalf("ScreenMock.HasMouse mock is already set by Set")
	}

	if mmHasMouse.defaultExpectation == nil {
		mmHasMouse.defaultExpectation = &ScreenMockHasMouseExpectation{}
	}

	return mmHasMouse
}

// Inspect accepts an inspector function that has same arguments as the Screen.HasMouse
func (mmHasMouse *mScreenMockHasMouse) Inspect(f func()) *mScreenMockHasMouse {
	if mmHasMouse.mock.inspectFuncHasMouse != nil {
		mmHasMouse.mock.t.Fatalf("Inspect function is already set for ScreenMock.HasMouse")
	}

	mmHasMouse.mock.inspectFuncHasMouse = f

	return mmHasMouse
}

// Return sets up results that will be returned by Screen.HasMouse
func (mmHasMouse *mScreenMockHasMouse) Return(b1 bool) *ScreenMock {
	if mmHasMouse.mock.funcHasMouse != nil {
		mmHasMouse.mock.t.Fatalf("ScreenMock.HasMouse mock is already set by Set")
	}

	if mmHasMouse.defaultExpectation == nil {
		mmHasMouse.defaultExpectation = &ScreenMockHasMouseExpectation{mock: mmHasMouse.mock}
	}
	mmHasMouse.defaultExpectation.results = &ScreenMockHasMouseResults{b1}
	return mmHasMouse.mock
}

//Set uses given function f to mock the Screen.HasMouse method
func (mmHasMouse *mScreenMockHasMouse) Set(f func() (b1 bool)) *ScreenMock {
	if mmHasMouse.defaultExpectation != nil {
		mmHasMouse.mock.t.Fatalf("Default expectation is already set for the Screen.HasMouse method")
	}

	if len(mmHasMouse.expectations) > 0 {
		mmHasMouse.mock.t.Fatalf("Some expectations are already set for the Screen.HasMouse method")
	}

	mmHasMouse.mock.funcHasMouse = f
	return mmHasMouse.mock
}

// HasMouse implements tcell.Screen
func (mmHasMouse *ScreenMock) HasMouse() (b1 bool) {
	mm_atomic.AddUint64(&mmHasMouse.beforeHasMouseCounter, 1)
	defer mm_atomic.AddUint64(&mmHasMouse.afterHasMouseCounter, 1)

	if mmHasMouse.inspectFuncHasMouse != nil {
		mmHasMouse.inspectFuncHasMouse()
	}

	if mmHasMouse.HasMouseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHasMouse.HasMouseMock.defaultExpectation.Counter, 1)

		mm_results := mmHasMouse.HasMouseMock.defaultExpectation.results
		if mm_results == nil {
			mmHasMouse.t.Fatal("No results are set for the ScreenMock.HasMouse")
		}
		return (*mm_results).b1
	}
	if mmHasMouse.funcHasMouse != nil {
		return mmHasMouse.funcHasMouse()
	}
	mmHasMouse.t.Fatalf("Unexpected call to ScreenMock.HasMouse.")
	return
}

// HasMouseAfterCounter returns a count of finished ScreenMock.HasMouse invocations
func (mmHasMouse *ScreenMock) HasMouseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasMouse.afterHasMouseCounter)
}

// HasMouseBeforeCounter returns a count of ScreenMock.HasMouse invocations
func (mmHasMouse *ScreenMock) HasMouseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHasMouse.beforeHasMouseCounter)
}

// MinimockHasMouseDone returns true if the count of the HasMouse invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockHasMouseDone() bool {
	for _, e := range m.HasMouseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasMouseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasMouseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasMouse != nil && mm_atomic.LoadUint64(&m.afterHasMouseCounter) < 1 {
		return false
	}
	return true
}

// MinimockHasMouseInspect logs each unmet expectation
func (m *ScreenMock) MinimockHasMouseInspect() {
	for _, e := range m.HasMouseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.HasMouse")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HasMouseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHasMouseCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.HasMouse")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHasMouse != nil && mm_atomic.LoadUint64(&m.afterHasMouseCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.HasMouse")
	}
}

type mScreenMockHideCursor struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockHideCursorExpectation
	expectations       []*ScreenMockHideCursorExpectation
}

// ScreenMockHideCursorExpectation specifies expectation struct of the Screen.HideCursor
type ScreenMockHideCursorExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.HideCursor
func (mmHideCursor *mScreenMockHideCursor) Expect() *mScreenMockHideCursor {
	if mmHideCursor.mock.funcHideCursor != nil {
		mmHideCursor.mock.t.Fatalf("ScreenMock.HideCursor mock is already set by Set")
	}

	if mmHideCursor.defaultExpectation == nil {
		mmHideCursor.defaultExpectation = &ScreenMockHideCursorExpectation{}
	}

	return mmHideCursor
}

// Inspect accepts an inspector function that has same arguments as the Screen.HideCursor
func (mmHideCursor *mScreenMockHideCursor) Inspect(f func()) *mScreenMockHideCursor {
	if mmHideCursor.mock.inspectFuncHideCursor != nil {
		mmHideCursor.mock.t.Fatalf("Inspect function is already set for ScreenMock.HideCursor")
	}

	mmHideCursor.mock.inspectFuncHideCursor = f

	return mmHideCursor
}

// Return sets up results that will be returned by Screen.HideCursor
func (mmHideCursor *mScreenMockHideCursor) Return() *ScreenMock {
	if mmHideCursor.mock.funcHideCursor != nil {
		mmHideCursor.mock.t.Fatalf("ScreenMock.HideCursor mock is already set by Set")
	}

	if mmHideCursor.defaultExpectation == nil {
		mmHideCursor.defaultExpectation = &ScreenMockHideCursorExpectation{mock: mmHideCursor.mock}
	}

	return mmHideCursor.mock
}

//Set uses given function f to mock the Screen.HideCursor method
func (mmHideCursor *mScreenMockHideCursor) Set(f func()) *ScreenMock {
	if mmHideCursor.defaultExpectation != nil {
		mmHideCursor.mock.t.Fatalf("Default expectation is already set for the Screen.HideCursor method")
	}

	if len(mmHideCursor.expectations) > 0 {
		mmHideCursor.mock.t.Fatalf("Some expectations are already set for the Screen.HideCursor method")
	}

	mmHideCursor.mock.funcHideCursor = f
	return mmHideCursor.mock
}

// HideCursor implements tcell.Screen
func (mmHideCursor *ScreenMock) HideCursor() {
	mm_atomic.AddUint64(&mmHideCursor.beforeHideCursorCounter, 1)
	defer mm_atomic.AddUint64(&mmHideCursor.afterHideCursorCounter, 1)

	if mmHideCursor.inspectFuncHideCursor != nil {
		mmHideCursor.inspectFuncHideCursor()
	}

	if mmHideCursor.HideCursorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHideCursor.HideCursorMock.defaultExpectation.Counter, 1)

		return

	}
	if mmHideCursor.funcHideCursor != nil {
		mmHideCursor.funcHideCursor()
		return
	}
	mmHideCursor.t.Fatalf("Unexpected call to ScreenMock.HideCursor.")

}

// HideCursorAfterCounter returns a count of finished ScreenMock.HideCursor invocations
func (mmHideCursor *ScreenMock) HideCursorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideCursor.afterHideCursorCounter)
}

// HideCursorBeforeCounter returns a count of ScreenMock.HideCursor invocations
func (mmHideCursor *ScreenMock) HideCursorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHideCursor.beforeHideCursorCounter)
}

// MinimockHideCursorDone returns true if the count of the HideCursor invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockHideCursorDone() bool {
	for _, e := range m.HideCursorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HideCursorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHideCursorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHideCursor != nil && mm_atomic.LoadUint64(&m.afterHideCursorCounter) < 1 {
		return false
	}
	return true
}

// MinimockHideCursorInspect logs each unmet expectation
func (m *ScreenMock) MinimockHideCursorInspect() {
	for _, e := range m.HideCursorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.HideCursor")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HideCursorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHideCursorCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.HideCursor")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHideCursor != nil && mm_atomic.LoadUint64(&m.afterHideCursorCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.HideCursor")
	}
}

type mScreenMockInit struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockInitExpectation
	expectations       []*ScreenMockInitExpectation
}

// ScreenMockInitExpectation specifies expectation struct of the Screen.Init
type ScreenMockInitExpectation struct {
	mock *ScreenMock

	results *ScreenMockInitResults
	Counter uint64
}

// ScreenMockInitResults contains results of the Screen.Init
type ScreenMockInitResults struct {
	err error
}

// Expect sets up expected params for Screen.Init
func (mmInit *mScreenMockInit) Expect() *mScreenMockInit {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("ScreenMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &ScreenMockInitExpectation{}
	}

	return mmInit
}

// Inspect accepts an inspector function that has same arguments as the Screen.Init
func (mmInit *mScreenMockInit) Inspect(f func()) *mScreenMockInit {
	if mmInit.mock.inspectFuncInit != nil {
		mmInit.mock.t.Fatalf("Inspect function is already set for ScreenMock.Init")
	}

	mmInit.mock.inspectFuncInit = f

	return mmInit
}

// Return sets up results that will be returned by Screen.Init
func (mmInit *mScreenMockInit) Return(err error) *ScreenMock {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("ScreenMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &ScreenMockInitExpectation{mock: mmInit.mock}
	}
	mmInit.defaultExpectation.results = &ScreenMockInitResults{err}
	return mmInit.mock
}

//Set uses given function f to mock the Screen.Init method
func (mmInit *mScreenMockInit) Set(f func() (err error)) *ScreenMock {
	if mmInit.defaultExpectation != nil {
		mmInit.mock.t.Fatalf("Default expectation is already set for the Screen.Init method")
	}

	if len(mmInit.expectations) > 0 {
		mmInit.mock.t.Fatalf("Some expectations are already set for the Screen.Init method")
	}

	mmInit.mock.funcInit = f
	return mmInit.mock
}

// Init implements tcell.Screen
func (mmInit *ScreenMock) Init() (err error) {
	mm_atomic.AddUint64(&mmInit.beforeInitCounter, 1)
	defer mm_atomic.AddUint64(&mmInit.afterInitCounter, 1)

	if mmInit.inspectFuncInit != nil {
		mmInit.inspectFuncInit()
	}

	if mmInit.InitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInit.InitMock.defaultExpectation.Counter, 1)

		mm_results := mmInit.InitMock.defaultExpectation.results
		if mm_results == nil {
			mmInit.t.Fatal("No results are set for the ScreenMock.Init")
		}
		return (*mm_results).err
	}
	if mmInit.funcInit != nil {
		return mmInit.funcInit()
	}
	mmInit.t.Fatalf("Unexpected call to ScreenMock.Init.")
	return
}

// InitAfterCounter returns a count of finished ScreenMock.Init invocations
func (mmInit *ScreenMock) InitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.afterInitCounter)
}

// InitBeforeCounter returns a count of ScreenMock.Init invocations
func (mmInit *ScreenMock) InitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.beforeInitCounter)
}

// MinimockInitDone returns true if the count of the Init invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockInitDone() bool {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitInspect logs each unmet expectation
func (m *ScreenMock) MinimockInitInspect() {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.Init")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Init")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && mm_atomic.LoadUint64(&m.afterInitCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Init")
	}
}

type mScreenMockPollEvent struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockPollEventExpectation
	expectations       []*ScreenMockPollEventExpectation
}

// ScreenMockPollEventExpectation specifies expectation struct of the Screen.PollEvent
type ScreenMockPollEventExpectation struct {
	mock *ScreenMock

	results *ScreenMockPollEventResults
	Counter uint64
}

// ScreenMockPollEventResults contains results of the Screen.PollEvent
type ScreenMockPollEventResults struct {
	e1 mm_tcell.Event
}

// Expect sets up expected params for Screen.PollEvent
func (mmPollEvent *mScreenMockPollEvent) Expect() *mScreenMockPollEvent {
	if mmPollEvent.mock.funcPollEvent != nil {
		mmPollEvent.mock.t.Fatalf("ScreenMock.PollEvent mock is already set by Set")
	}

	if mmPollEvent.defaultExpectation == nil {
		mmPollEvent.defaultExpectation = &ScreenMockPollEventExpectation{}
	}

	return mmPollEvent
}

// Inspect accepts an inspector function that has same arguments as the Screen.PollEvent
func (mmPollEvent *mScreenMockPollEvent) Inspect(f func()) *mScreenMockPollEvent {
	if mmPollEvent.mock.inspectFuncPollEvent != nil {
		mmPollEvent.mock.t.Fatalf("Inspect function is already set for ScreenMock.PollEvent")
	}

	mmPollEvent.mock.inspectFuncPollEvent = f

	return mmPollEvent
}

// Return sets up results that will be returned by Screen.PollEvent
func (mmPollEvent *mScreenMockPollEvent) Return(e1 mm_tcell.Event) *ScreenMock {
	if mmPollEvent.mock.funcPollEvent != nil {
		mmPollEvent.mock.t.Fatalf("ScreenMock.PollEvent mock is already set by Set")
	}

	if mmPollEvent.defaultExpectation == nil {
		mmPollEvent.defaultExpectation = &ScreenMockPollEventExpectation{mock: mmPollEvent.mock}
	}
	mmPollEvent.defaultExpectation.results = &ScreenMockPollEventResults{e1}
	return mmPollEvent.mock
}

//Set uses given function f to mock the Screen.PollEvent method
func (mmPollEvent *mScreenMockPollEvent) Set(f func() (e1 mm_tcell.Event)) *ScreenMock {
	if mmPollEvent.defaultExpectation != nil {
		mmPollEvent.mock.t.Fatalf("Default expectation is already set for the Screen.PollEvent method")
	}

	if len(mmPollEvent.expectations) > 0 {
		mmPollEvent.mock.t.Fatalf("Some expectations are already set for the Screen.PollEvent method")
	}

	mmPollEvent.mock.funcPollEvent = f
	return mmPollEvent.mock
}

// PollEvent implements tcell.Screen
func (mmPollEvent *ScreenMock) PollEvent() (e1 mm_tcell.Event) {
	mm_atomic.AddUint64(&mmPollEvent.beforePollEventCounter, 1)
	defer mm_atomic.AddUint64(&mmPollEvent.afterPollEventCounter, 1)

	if mmPollEvent.inspectFuncPollEvent != nil {
		mmPollEvent.inspectFuncPollEvent()
	}

	if mmPollEvent.PollEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPollEvent.PollEventMock.defaultExpectation.Counter, 1)

		mm_results := mmPollEvent.PollEventMock.defaultExpectation.results
		if mm_results == nil {
			mmPollEvent.t.Fatal("No results are set for the ScreenMock.PollEvent")
		}
		return (*mm_results).e1
	}
	if mmPollEvent.funcPollEvent != nil {
		return mmPollEvent.funcPollEvent()
	}
	mmPollEvent.t.Fatalf("Unexpected call to ScreenMock.PollEvent.")
	return
}

// PollEventAfterCounter returns a count of finished ScreenMock.PollEvent invocations
func (mmPollEvent *ScreenMock) PollEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPollEvent.afterPollEventCounter)
}

// PollEventBeforeCounter returns a count of ScreenMock.PollEvent invocations
func (mmPollEvent *ScreenMock) PollEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPollEvent.beforePollEventCounter)
}

// MinimockPollEventDone returns true if the count of the PollEvent invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockPollEventDone() bool {
	for _, e := range m.PollEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPollEvent != nil && mm_atomic.LoadUint64(&m.afterPollEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockPollEventInspect logs each unmet expectation
func (m *ScreenMock) MinimockPollEventInspect() {
	for _, e := range m.PollEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.PollEvent")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollEventCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.PollEvent")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPollEvent != nil && mm_atomic.LoadUint64(&m.afterPollEventCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.PollEvent")
	}
}

type mScreenMockPostEvent struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockPostEventExpectation
	expectations       []*ScreenMockPostEventExpectation

	callArgs []*ScreenMockPostEventParams
	mutex    sync.RWMutex
}

// ScreenMockPostEventExpectation specifies expectation struct of the Screen.PostEvent
type ScreenMockPostEventExpectation struct {
	mock    *ScreenMock
	params  *ScreenMockPostEventParams
	results *ScreenMockPostEventResults
	Counter uint64
}

// ScreenMockPostEventParams contains parameters of the Screen.PostEvent
type ScreenMockPostEventParams struct {
	ev mm_tcell.Event
}

// ScreenMockPostEventResults contains results of the Screen.PostEvent
type ScreenMockPostEventResults struct {
	err error
}

// Expect sets up expected params for Screen.PostEvent
func (mmPostEvent *mScreenMockPostEvent) Expect(ev mm_tcell.Event) *mScreenMockPostEvent {
	if mmPostEvent.mock.funcPostEvent != nil {
		mmPostEvent.mock.t.Fatalf("ScreenMock.PostEvent mock is already set by Set")
	}

	if mmPostEvent.defaultExpectation == nil {
		mmPostEvent.defaultExpectation = &ScreenMockPostEventExpectation{}
	}

	mmPostEvent.defaultExpectation.params = &ScreenMockPostEventParams{ev}
	for _, e := range mmPostEvent.expectations {
		if minimock.Equal(e.params, mmPostEvent.defaultExpectation.params) {
			mmPostEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPostEvent.defaultExpectation.params)
		}
	}

	return mmPostEvent
}

// Inspect accepts an inspector function that has same arguments as the Screen.PostEvent
func (mmPostEvent *mScreenMockPostEvent) Inspect(f func(ev mm_tcell.Event)) *mScreenMockPostEvent {
	if mmPostEvent.mock.inspectFuncPostEvent != nil {
		mmPostEvent.mock.t.Fatalf("Inspect function is already set for ScreenMock.PostEvent")
	}

	mmPostEvent.mock.inspectFuncPostEvent = f

	return mmPostEvent
}

// Return sets up results that will be returned by Screen.PostEvent
func (mmPostEvent *mScreenMockPostEvent) Return(err error) *ScreenMock {
	if mmPostEvent.mock.funcPostEvent != nil {
		mmPostEvent.mock.t.Fatalf("ScreenMock.PostEvent mock is already set by Set")
	}

	if mmPostEvent.defaultExpectation == nil {
		mmPostEvent.defaultExpectation = &ScreenMockPostEventExpectation{mock: mmPostEvent.mock}
	}
	mmPostEvent.defaultExpectation.results = &ScreenMockPostEventResults{err}
	return mmPostEvent.mock
}

//Set uses given function f to mock the Screen.PostEvent method
func (mmPostEvent *mScreenMockPostEvent) Set(f func(ev mm_tcell.Event) (err error)) *ScreenMock {
	if mmPostEvent.defaultExpectation != nil {
		mmPostEvent.mock.t.Fatalf("Default expectation is already set for the Screen.PostEvent method")
	}

	if len(mmPostEvent.expectations) > 0 {
		mmPostEvent.mock.t.Fatalf("Some expectations are already set for the Screen.PostEvent method")
	}

	mmPostEvent.mock.funcPostEvent = f
	return mmPostEvent.mock
}

// When sets expectation for the Screen.PostEvent which will trigger the result defined by the following
// Then helper
func (mmPostEvent *mScreenMockPostEvent) When(ev mm_tcell.Event) *ScreenMockPostEventExpectation {
	if mmPostEvent.mock.funcPostEvent != nil {
		mmPostEvent.mock.t.Fatalf("ScreenMock.PostEvent mock is already set by Set")
	}

	expectation := &ScreenMockPostEventExpectation{
		mock:   mmPostEvent.mock,
		params: &ScreenMockPostEventParams{ev},
	}
	mmPostEvent.expectations = append(mmPostEvent.expectations, expectation)
	return expectation
}

// Then sets up Screen.PostEvent return parameters for the expectation previously defined by the When method
func (e *ScreenMockPostEventExpectation) Then(err error) *ScreenMock {
	e.results = &ScreenMockPostEventResults{err}
	return e.mock
}

// PostEvent implements tcell.Screen
func (mmPostEvent *ScreenMock) PostEvent(ev mm_tcell.Event) (err error) {
	mm_atomic.AddUint64(&mmPostEvent.beforePostEventCounter, 1)
	defer mm_atomic.AddUint64(&mmPostEvent.afterPostEventCounter, 1)

	if mmPostEvent.inspectFuncPostEvent != nil {
		mmPostEvent.inspectFuncPostEvent(ev)
	}

	mm_params := &ScreenMockPostEventParams{ev}

	// Record call args
	mmPostEvent.PostEventMock.mutex.Lock()
	mmPostEvent.PostEventMock.callArgs = append(mmPostEvent.PostEventMock.callArgs, mm_params)
	mmPostEvent.PostEventMock.mutex.Unlock()

	for _, e := range mmPostEvent.PostEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPostEvent.PostEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPostEvent.PostEventMock.defaultExpectation.Counter, 1)
		mm_want := mmPostEvent.PostEventMock.defaultExpectation.params
		mm_got := ScreenMockPostEventParams{ev}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPostEvent.t.Errorf("ScreenMock.PostEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPostEvent.PostEventMock.defaultExpectation.results
		if mm_results == nil {
			mmPostEvent.t.Fatal("No results are set for the ScreenMock.PostEvent")
		}
		return (*mm_results).err
	}
	if mmPostEvent.funcPostEvent != nil {
		return mmPostEvent.funcPostEvent(ev)
	}
	mmPostEvent.t.Fatalf("Unexpected call to ScreenMock.PostEvent. %v", ev)
	return
}

// PostEventAfterCounter returns a count of finished ScreenMock.PostEvent invocations
func (mmPostEvent *ScreenMock) PostEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostEvent.afterPostEventCounter)
}

// PostEventBeforeCounter returns a count of ScreenMock.PostEvent invocations
func (mmPostEvent *ScreenMock) PostEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostEvent.beforePostEventCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.PostEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPostEvent *mScreenMockPostEvent) Calls() []*ScreenMockPostEventParams {
	mmPostEvent.mutex.RLock()

	argCopy := make([]*ScreenMockPostEventParams, len(mmPostEvent.callArgs))
	copy(argCopy, mmPostEvent.callArgs)

	mmPostEvent.mutex.RUnlock()

	return argCopy
}

// MinimockPostEventDone returns true if the count of the PostEvent invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockPostEventDone() bool {
	for _, e := range m.PostEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostEvent != nil && mm_atomic.LoadUint64(&m.afterPostEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockPostEventInspect logs each unmet expectation
func (m *ScreenMock) MinimockPostEventInspect() {
	for _, e := range m.PostEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.PostEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostEventCounter) < 1 {
		if m.PostEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.PostEvent")
		} else {
			m.t.Errorf("Expected call to ScreenMock.PostEvent with params: %#v", *m.PostEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostEvent != nil && mm_atomic.LoadUint64(&m.afterPostEventCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.PostEvent")
	}
}

type mScreenMockPostEventWait struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockPostEventWaitExpectation
	expectations       []*ScreenMockPostEventWaitExpectation

	callArgs []*ScreenMockPostEventWaitParams
	mutex    sync.RWMutex
}

// ScreenMockPostEventWaitExpectation specifies expectation struct of the Screen.PostEventWait
type ScreenMockPostEventWaitExpectation struct {
	mock   *ScreenMock
	params *ScreenMockPostEventWaitParams

	Counter uint64
}

// ScreenMockPostEventWaitParams contains parameters of the Screen.PostEventWait
type ScreenMockPostEventWaitParams struct {
	ev mm_tcell.Event
}

// Expect sets up expected params for Screen.PostEventWait
func (mmPostEventWait *mScreenMockPostEventWait) Expect(ev mm_tcell.Event) *mScreenMockPostEventWait {
	if mmPostEventWait.mock.funcPostEventWait != nil {
		mmPostEventWait.mock.t.Fatalf("ScreenMock.PostEventWait mock is already set by Set")
	}

	if mmPostEventWait.defaultExpectation == nil {
		mmPostEventWait.defaultExpectation = &ScreenMockPostEventWaitExpectation{}
	}

	mmPostEventWait.defaultExpectation.params = &ScreenMockPostEventWaitParams{ev}
	for _, e := range mmPostEventWait.expectations {
		if minimock.Equal(e.params, mmPostEventWait.defaultExpectation.params) {
			mmPostEventWait.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPostEventWait.defaultExpectation.params)
		}
	}

	return mmPostEventWait
}

// Inspect accepts an inspector function that has same arguments as the Screen.PostEventWait
func (mmPostEventWait *mScreenMockPostEventWait) Inspect(f func(ev mm_tcell.Event)) *mScreenMockPostEventWait {
	if mmPostEventWait.mock.inspectFuncPostEventWait != nil {
		mmPostEventWait.mock.t.Fatalf("Inspect function is already set for ScreenMock.PostEventWait")
	}

	mmPostEventWait.mock.inspectFuncPostEventWait = f

	return mmPostEventWait
}

// Return sets up results that will be returned by Screen.PostEventWait
func (mmPostEventWait *mScreenMockPostEventWait) Return() *ScreenMock {
	if mmPostEventWait.mock.funcPostEventWait != nil {
		mmPostEventWait.mock.t.Fatalf("ScreenMock.PostEventWait mock is already set by Set")
	}

	if mmPostEventWait.defaultExpectation == nil {
		mmPostEventWait.defaultExpectation = &ScreenMockPostEventWaitExpectation{mock: mmPostEventWait.mock}
	}

	return mmPostEventWait.mock
}

//Set uses given function f to mock the Screen.PostEventWait method
func (mmPostEventWait *mScreenMockPostEventWait) Set(f func(ev mm_tcell.Event)) *ScreenMock {
	if mmPostEventWait.defaultExpectation != nil {
		mmPostEventWait.mock.t.Fatalf("Default expectation is already set for the Screen.PostEventWait method")
	}

	if len(mmPostEventWait.expectations) > 0 {
		mmPostEventWait.mock.t.Fatalf("Some expectations are already set for the Screen.PostEventWait method")
	}

	mmPostEventWait.mock.funcPostEventWait = f
	return mmPostEventWait.mock
}

// PostEventWait implements tcell.Screen
func (mmPostEventWait *ScreenMock) PostEventWait(ev mm_tcell.Event) {
	mm_atomic.AddUint64(&mmPostEventWait.beforePostEventWaitCounter, 1)
	defer mm_atomic.AddUint64(&mmPostEventWait.afterPostEventWaitCounter, 1)

	if mmPostEventWait.inspectFuncPostEventWait != nil {
		mmPostEventWait.inspectFuncPostEventWait(ev)
	}

	mm_params := &ScreenMockPostEventWaitParams{ev}

	// Record call args
	mmPostEventWait.PostEventWaitMock.mutex.Lock()
	mmPostEventWait.PostEventWaitMock.callArgs = append(mmPostEventWait.PostEventWaitMock.callArgs, mm_params)
	mmPostEventWait.PostEventWaitMock.mutex.Unlock()

	for _, e := range mmPostEventWait.PostEventWaitMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPostEventWait.PostEventWaitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPostEventWait.PostEventWaitMock.defaultExpectation.Counter, 1)
		mm_want := mmPostEventWait.PostEventWaitMock.defaultExpectation.params
		mm_got := ScreenMockPostEventWaitParams{ev}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPostEventWait.t.Errorf("ScreenMock.PostEventWait got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPostEventWait.funcPostEventWait != nil {
		mmPostEventWait.funcPostEventWait(ev)
		return
	}
	mmPostEventWait.t.Fatalf("Unexpected call to ScreenMock.PostEventWait. %v", ev)

}

// PostEventWaitAfterCounter returns a count of finished ScreenMock.PostEventWait invocations
func (mmPostEventWait *ScreenMock) PostEventWaitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostEventWait.afterPostEventWaitCounter)
}

// PostEventWaitBeforeCounter returns a count of ScreenMock.PostEventWait invocations
func (mmPostEventWait *ScreenMock) PostEventWaitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostEventWait.beforePostEventWaitCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.PostEventWait.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPostEventWait *mScreenMockPostEventWait) Calls() []*ScreenMockPostEventWaitParams {
	mmPostEventWait.mutex.RLock()

	argCopy := make([]*ScreenMockPostEventWaitParams, len(mmPostEventWait.callArgs))
	copy(argCopy, mmPostEventWait.callArgs)

	mmPostEventWait.mutex.RUnlock()

	return argCopy
}

// MinimockPostEventWaitDone returns true if the count of the PostEventWait invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockPostEventWaitDone() bool {
	for _, e := range m.PostEventWaitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostEventWaitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostEventWaitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostEventWait != nil && mm_atomic.LoadUint64(&m.afterPostEventWaitCounter) < 1 {
		return false
	}
	return true
}

// MinimockPostEventWaitInspect logs each unmet expectation
func (m *ScreenMock) MinimockPostEventWaitInspect() {
	for _, e := range m.PostEventWaitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.PostEventWait with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostEventWaitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostEventWaitCounter) < 1 {
		if m.PostEventWaitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.PostEventWait")
		} else {
			m.t.Errorf("Expected call to ScreenMock.PostEventWait with params: %#v", *m.PostEventWaitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostEventWait != nil && mm_atomic.LoadUint64(&m.afterPostEventWaitCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.PostEventWait")
	}
}

type mScreenMockRegisterRuneFallback struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockRegisterRuneFallbackExpectation
	expectations       []*ScreenMockRegisterRuneFallbackExpectation

	callArgs []*ScreenMockRegisterRuneFallbackParams
	mutex    sync.RWMutex
}

// ScreenMockRegisterRuneFallbackExpectation specifies expectation struct of the Screen.RegisterRuneFallback
type ScreenMockRegisterRuneFallbackExpectation struct {
	mock   *ScreenMock
	params *ScreenMockRegisterRuneFallbackParams

	Counter uint64
}

// ScreenMockRegisterRuneFallbackParams contains parameters of the Screen.RegisterRuneFallback
type ScreenMockRegisterRuneFallbackParams struct {
	r     rune
	subst string
}

// Expect sets up expected params for Screen.RegisterRuneFallback
func (mmRegisterRuneFallback *mScreenMockRegisterRuneFallback) Expect(r rune, subst string) *mScreenMockRegisterRuneFallback {
	if mmRegisterRuneFallback.mock.funcRegisterRuneFallback != nil {
		mmRegisterRuneFallback.mock.t.Fatalf("ScreenMock.RegisterRuneFallback mock is already set by Set")
	}

	if mmRegisterRuneFallback.defaultExpectation == nil {
		mmRegisterRuneFallback.defaultExpectation = &ScreenMockRegisterRuneFallbackExpectation{}
	}

	mmRegisterRuneFallback.defaultExpectation.params = &ScreenMockRegisterRuneFallbackParams{r, subst}
	for _, e := range mmRegisterRuneFallback.expectations {
		if minimock.Equal(e.params, mmRegisterRuneFallback.defaultExpectation.params) {
			mmRegisterRuneFallback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterRuneFallback.defaultExpectation.params)
		}
	}

	return mmRegisterRuneFallback
}

// Inspect accepts an inspector function that has same arguments as the Screen.RegisterRuneFallback
func (mmRegisterRuneFallback *mScreenMockRegisterRuneFallback) Inspect(f func(r rune, subst string)) *mScreenMockRegisterRuneFallback {
	if mmRegisterRuneFallback.mock.inspectFuncRegisterRuneFallback != nil {
		mmRegisterRuneFallback.mock.t.Fatalf("Inspect function is already set for ScreenMock.RegisterRuneFallback")
	}

	mmRegisterRuneFallback.mock.inspectFuncRegisterRuneFallback = f

	return mmRegisterRuneFallback
}

// Return sets up results that will be returned by Screen.RegisterRuneFallback
func (mmRegisterRuneFallback *mScreenMockRegisterRuneFallback) Return() *ScreenMock {
	if mmRegisterRuneFallback.mock.funcRegisterRuneFallback != nil {
		mmRegisterRuneFallback.mock.t.Fatalf("ScreenMock.RegisterRuneFallback mock is already set by Set")
	}

	if mmRegisterRuneFallback.defaultExpectation == nil {
		mmRegisterRuneFallback.defaultExpectation = &ScreenMockRegisterRuneFallbackExpectation{mock: mmRegisterRuneFallback.mock}
	}

	return mmRegisterRuneFallback.mock
}

//Set uses given function f to mock the Screen.RegisterRuneFallback method
func (mmRegisterRuneFallback *mScreenMockRegisterRuneFallback) Set(f func(r rune, subst string)) *ScreenMock {
	if mmRegisterRuneFallback.defaultExpectation != nil {
		mmRegisterRuneFallback.mock.t.Fatalf("Default expectation is already set for the Screen.RegisterRuneFallback method")
	}

	if len(mmRegisterRuneFallback.expectations) > 0 {
		mmRegisterRuneFallback.mock.t.Fatalf("Some expectations are already set for the Screen.RegisterRuneFallback method")
	}

	mmRegisterRuneFallback.mock.funcRegisterRuneFallback = f
	return mmRegisterRuneFallback.mock
}

// RegisterRuneFallback implements tcell.Screen
func (mmRegisterRuneFallback *ScreenMock) RegisterRuneFallback(r rune, subst string) {
	mm_atomic.AddUint64(&mmRegisterRuneFallback.beforeRegisterRuneFallbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterRuneFallback.afterRegisterRuneFallbackCounter, 1)

	if mmRegisterRuneFallback.inspectFuncRegisterRuneFallback != nil {
		mmRegisterRuneFallback.inspectFuncRegisterRuneFallback(r, subst)
	}

	mm_params := &ScreenMockRegisterRuneFallbackParams{r, subst}

	// Record call args
	mmRegisterRuneFallback.RegisterRuneFallbackMock.mutex.Lock()
	mmRegisterRuneFallback.RegisterRuneFallbackMock.callArgs = append(mmRegisterRuneFallback.RegisterRuneFallbackMock.callArgs, mm_params)
	mmRegisterRuneFallback.RegisterRuneFallbackMock.mutex.Unlock()

	for _, e := range mmRegisterRuneFallback.RegisterRuneFallbackMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmRegisterRuneFallback.RegisterRuneFallbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterRuneFallback.RegisterRuneFallbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterRuneFallback.RegisterRuneFallbackMock.defaultExpectation.params
		mm_got := ScreenMockRegisterRuneFallbackParams{r, subst}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterRuneFallback.t.Errorf("ScreenMock.RegisterRuneFallback got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmRegisterRuneFallback.funcRegisterRuneFallback != nil {
		mmRegisterRuneFallback.funcRegisterRuneFallback(r, subst)
		return
	}
	mmRegisterRuneFallback.t.Fatalf("Unexpected call to ScreenMock.RegisterRuneFallback. %v %v", r, subst)

}

// RegisterRuneFallbackAfterCounter returns a count of finished ScreenMock.RegisterRuneFallback invocations
func (mmRegisterRuneFallback *ScreenMock) RegisterRuneFallbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterRuneFallback.afterRegisterRuneFallbackCounter)
}

// RegisterRuneFallbackBeforeCounter returns a count of ScreenMock.RegisterRuneFallback invocations
func (mmRegisterRuneFallback *ScreenMock) RegisterRuneFallbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterRuneFallback.beforeRegisterRuneFallbackCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.RegisterRuneFallback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterRuneFallback *mScreenMockRegisterRuneFallback) Calls() []*ScreenMockRegisterRuneFallbackParams {
	mmRegisterRuneFallback.mutex.RLock()

	argCopy := make([]*ScreenMockRegisterRuneFallbackParams, len(mmRegisterRuneFallback.callArgs))
	copy(argCopy, mmRegisterRuneFallback.callArgs)

	mmRegisterRuneFallback.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterRuneFallbackDone returns true if the count of the RegisterRuneFallback invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockRegisterRuneFallbackDone() bool {
	for _, e := range m.RegisterRuneFallbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterRuneFallbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterRuneFallbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterRuneFallback != nil && mm_atomic.LoadUint64(&m.afterRegisterRuneFallbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterRuneFallbackInspect logs each unmet expectation
func (m *ScreenMock) MinimockRegisterRuneFallbackInspect() {
	for _, e := range m.RegisterRuneFallbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.RegisterRuneFallback with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterRuneFallbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterRuneFallbackCounter) < 1 {
		if m.RegisterRuneFallbackMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.RegisterRuneFallback")
		} else {
			m.t.Errorf("Expected call to ScreenMock.RegisterRuneFallback with params: %#v", *m.RegisterRuneFallbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterRuneFallback != nil && mm_atomic.LoadUint64(&m.afterRegisterRuneFallbackCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.RegisterRuneFallback")
	}
}

type mScreenMockResize struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockResizeExpectation
	expectations       []*ScreenMockResizeExpectation

	callArgs []*ScreenMockResizeParams
	mutex    sync.RWMutex
}

// ScreenMockResizeExpectation specifies expectation struct of the Screen.Resize
type ScreenMockResizeExpectation struct {
	mock   *ScreenMock
	params *ScreenMockResizeParams

	Counter uint64
}

// ScreenMockResizeParams contains parameters of the Screen.Resize
type ScreenMockResizeParams struct {
	i1 int
	i2 int
	i3 int
	i4 int
}

// Expect sets up expected params for Screen.Resize
func (mmResize *mScreenMockResize) Expect(i1 int, i2 int, i3 int, i4 int) *mScreenMockResize {
	if mmResize.mock.funcResize != nil {
		mmResize.mock.t.Fatalf("ScreenMock.Resize mock is already set by Set")
	}

	if mmResize.defaultExpectation == nil {
		mmResize.defaultExpectation = &ScreenMockResizeExpectation{}
	}

	mmResize.defaultExpectation.params = &ScreenMockResizeParams{i1, i2, i3, i4}
	for _, e := range mmResize.expectations {
		if minimock.Equal(e.params, mmResize.defaultExpectation.params) {
			mmResize.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmResize.defaultExpectation.params)
		}
	}

	return mmResize
}

// Inspect accepts an inspector function that has same arguments as the Screen.Resize
func (mmResize *mScreenMockResize) Inspect(f func(i1 int, i2 int, i3 int, i4 int)) *mScreenMockResize {
	if mmResize.mock.inspectFuncResize != nil {
		mmResize.mock.t.Fatalf("Inspect function is already set for ScreenMock.Resize")
	}

	mmResize.mock.inspectFuncResize = f

	return mmResize
}

// Return sets up results that will be returned by Screen.Resize
func (mmResize *mScreenMockResize) Return() *ScreenMock {
	if mmResize.mock.funcResize != nil {
		mmResize.mock.t.Fatalf("ScreenMock.Resize mock is already set by Set")
	}

	if mmResize.defaultExpectation == nil {
		mmResize.defaultExpectation = &ScreenMockResizeExpectation{mock: mmResize.mock}
	}

	return mmResize.mock
}

//Set uses given function f to mock the Screen.Resize method
func (mmResize *mScreenMockResize) Set(f func(i1 int, i2 int, i3 int, i4 int)) *ScreenMock {
	if mmResize.defaultExpectation != nil {
		mmResize.mock.t.Fatalf("Default expectation is already set for the Screen.Resize method")
	}

	if len(mmResize.expectations) > 0 {
		mmResize.mock.t.Fatalf("Some expectations are already set for the Screen.Resize method")
	}

	mmResize.mock.funcResize = f
	return mmResize.mock
}

// Resize implements tcell.Screen
func (mmResize *ScreenMock) Resize(i1 int, i2 int, i3 int, i4 int) {
	mm_atomic.AddUint64(&mmResize.beforeResizeCounter, 1)
	defer mm_atomic.AddUint64(&mmResize.afterResizeCounter, 1)

	if mmResize.inspectFuncResize != nil {
		mmResize.inspectFuncResize(i1, i2, i3, i4)
	}

	mm_params := &ScreenMockResizeParams{i1, i2, i3, i4}

	// Record call args
	mmResize.ResizeMock.mutex.Lock()
	mmResize.ResizeMock.callArgs = append(mmResize.ResizeMock.callArgs, mm_params)
	mmResize.ResizeMock.mutex.Unlock()

	for _, e := range mmResize.ResizeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmResize.ResizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmResize.ResizeMock.defaultExpectation.Counter, 1)
		mm_want := mmResize.ResizeMock.defaultExpectation.params
		mm_got := ScreenMockResizeParams{i1, i2, i3, i4}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmResize.t.Errorf("ScreenMock.Resize got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmResize.funcResize != nil {
		mmResize.funcResize(i1, i2, i3, i4)
		return
	}
	mmResize.t.Fatalf("Unexpected call to ScreenMock.Resize. %v %v %v %v", i1, i2, i3, i4)

}

// ResizeAfterCounter returns a count of finished ScreenMock.Resize invocations
func (mmResize *ScreenMock) ResizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResize.afterResizeCounter)
}

// ResizeBeforeCounter returns a count of ScreenMock.Resize invocations
func (mmResize *ScreenMock) ResizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmResize.beforeResizeCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.Resize.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmResize *mScreenMockResize) Calls() []*ScreenMockResizeParams {
	mmResize.mutex.RLock()

	argCopy := make([]*ScreenMockResizeParams, len(mmResize.callArgs))
	copy(argCopy, mmResize.callArgs)

	mmResize.mutex.RUnlock()

	return argCopy
}

// MinimockResizeDone returns true if the count of the Resize invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockResizeDone() bool {
	for _, e := range m.ResizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResize != nil && mm_atomic.LoadUint64(&m.afterResizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockResizeInspect logs each unmet expectation
func (m *ScreenMock) MinimockResizeInspect() {
	for _, e := range m.ResizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.Resize with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ResizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterResizeCounter) < 1 {
		if m.ResizeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.Resize")
		} else {
			m.t.Errorf("Expected call to ScreenMock.Resize with params: %#v", *m.ResizeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcResize != nil && mm_atomic.LoadUint64(&m.afterResizeCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Resize")
	}
}

type mScreenMockSetCell struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockSetCellExpectation
	expectations       []*ScreenMockSetCellExpectation

	callArgs []*ScreenMockSetCellParams
	mutex    sync.RWMutex
}

// ScreenMockSetCellExpectation specifies expectation struct of the Screen.SetCell
type ScreenMockSetCellExpectation struct {
	mock   *ScreenMock
	params *ScreenMockSetCellParams

	Counter uint64
}

// ScreenMockSetCellParams contains parameters of the Screen.SetCell
type ScreenMockSetCellParams struct {
	x     int
	y     int
	style mm_tcell.Style
	ch    []rune
}

// Expect sets up expected params for Screen.SetCell
func (mmSetCell *mScreenMockSetCell) Expect(x int, y int, style mm_tcell.Style, ch ...rune) *mScreenMockSetCell {
	if mmSetCell.mock.funcSetCell != nil {
		mmSetCell.mock.t.Fatalf("ScreenMock.SetCell mock is already set by Set")
	}

	if mmSetCell.defaultExpectation == nil {
		mmSetCell.defaultExpectation = &ScreenMockSetCellExpectation{}
	}

	mmSetCell.defaultExpectation.params = &ScreenMockSetCellParams{x, y, style, ch}
	for _, e := range mmSetCell.expectations {
		if minimock.Equal(e.params, mmSetCell.defaultExpectation.params) {
			mmSetCell.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetCell.defaultExpectation.params)
		}
	}

	return mmSetCell
}

// Inspect accepts an inspector function that has same arguments as the Screen.SetCell
func (mmSetCell *mScreenMockSetCell) Inspect(f func(x int, y int, style mm_tcell.Style, ch ...rune)) *mScreenMockSetCell {
	if mmSetCell.mock.inspectFuncSetCell != nil {
		mmSetCell.mock.t.Fatalf("Inspect function is already set for ScreenMock.SetCell")
	}

	mmSetCell.mock.inspectFuncSetCell = f

	return mmSetCell
}

// Return sets up results that will be returned by Screen.SetCell
func (mmSetCell *mScreenMockSetCell) Return() *ScreenMock {
	if mmSetCell.mock.funcSetCell != nil {
		mmSetCell.mock.t.Fatalf("ScreenMock.SetCell mock is already set by Set")
	}

	if mmSetCell.defaultExpectation == nil {
		mmSetCell.defaultExpectation = &ScreenMockSetCellExpectation{mock: mmSetCell.mock}
	}

	return mmSetCell.mock
}

//Set uses given function f to mock the Screen.SetCell method
func (mmSetCell *mScreenMockSetCell) Set(f func(x int, y int, style mm_tcell.Style, ch ...rune)) *ScreenMock {
	if mmSetCell.defaultExpectation != nil {
		mmSetCell.mock.t.Fatalf("Default expectation is already set for the Screen.SetCell method")
	}

	if len(mmSetCell.expectations) > 0 {
		mmSetCell.mock.t.Fatalf("Some expectations are already set for the Screen.SetCell method")
	}

	mmSetCell.mock.funcSetCell = f
	return mmSetCell.mock
}

// SetCell implements tcell.Screen
func (mmSetCell *ScreenMock) SetCell(x int, y int, style mm_tcell.Style, ch ...rune) {
	mm_atomic.AddUint64(&mmSetCell.beforeSetCellCounter, 1)
	defer mm_atomic.AddUint64(&mmSetCell.afterSetCellCounter, 1)

	if mmSetCell.inspectFuncSetCell != nil {
		mmSetCell.inspectFuncSetCell(x, y, style, ch...)
	}

	mm_params := &ScreenMockSetCellParams{x, y, style, ch}

	// Record call args
	mmSetCell.SetCellMock.mutex.Lock()
	mmSetCell.SetCellMock.callArgs = append(mmSetCell.SetCellMock.callArgs, mm_params)
	mmSetCell.SetCellMock.mutex.Unlock()

	for _, e := range mmSetCell.SetCellMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetCell.SetCellMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetCell.SetCellMock.defaultExpectation.Counter, 1)
		mm_want := mmSetCell.SetCellMock.defaultExpectation.params
		mm_got := ScreenMockSetCellParams{x, y, style, ch}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetCell.t.Errorf("ScreenMock.SetCell got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetCell.funcSetCell != nil {
		mmSetCell.funcSetCell(x, y, style, ch...)
		return
	}
	mmSetCell.t.Fatalf("Unexpected call to ScreenMock.SetCell. %v %v %v %v", x, y, style, ch)

}

// SetCellAfterCounter returns a count of finished ScreenMock.SetCell invocations
func (mmSetCell *ScreenMock) SetCellAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCell.afterSetCellCounter)
}

// SetCellBeforeCounter returns a count of ScreenMock.SetCell invocations
func (mmSetCell *ScreenMock) SetCellBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCell.beforeSetCellCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.SetCell.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetCell *mScreenMockSetCell) Calls() []*ScreenMockSetCellParams {
	mmSetCell.mutex.RLock()

	argCopy := make([]*ScreenMockSetCellParams, len(mmSetCell.callArgs))
	copy(argCopy, mmSetCell.callArgs)

	mmSetCell.mutex.RUnlock()

	return argCopy
}

// MinimockSetCellDone returns true if the count of the SetCell invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockSetCellDone() bool {
	for _, e := range m.SetCellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetCellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCellCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCell != nil && mm_atomic.LoadUint64(&m.afterSetCellCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetCellInspect logs each unmet expectation
func (m *ScreenMock) MinimockSetCellInspect() {
	for _, e := range m.SetCellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.SetCell with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetCellMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCellCounter) < 1 {
		if m.SetCellMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.SetCell")
		} else {
			m.t.Errorf("Expected call to ScreenMock.SetCell with params: %#v", *m.SetCellMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCell != nil && mm_atomic.LoadUint64(&m.afterSetCellCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.SetCell")
	}
}

type mScreenMockSetContent struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockSetContentExpectation
	expectations       []*ScreenMockSetContentExpectation

	callArgs []*ScreenMockSetContentParams
	mutex    sync.RWMutex
}

// ScreenMockSetContentExpectation specifies expectation struct of the Screen.SetContent
type ScreenMockSetContentExpectation struct {
	mock   *ScreenMock
	params *ScreenMockSetContentParams

	Counter uint64
}

// ScreenMockSetContentParams contains parameters of the Screen.SetContent
type ScreenMockSetContentParams struct {
	x     int
	y     int
	mainc rune
	combc []rune
	style mm_tcell.Style
}

// Expect sets up expected params for Screen.SetContent
func (mmSetContent *mScreenMockSetContent) Expect(x int, y int, mainc rune, combc []rune, style mm_tcell.Style) *mScreenMockSetContent {
	if mmSetContent.mock.funcSetContent != nil {
		mmSetContent.mock.t.Fatalf("ScreenMock.SetContent mock is already set by Set")
	}

	if mmSetContent.defaultExpectation == nil {
		mmSetContent.defaultExpectation = &ScreenMockSetContentExpectation{}
	}

	mmSetContent.defaultExpectation.params = &ScreenMockSetContentParams{x, y, mainc, combc, style}
	for _, e := range mmSetContent.expectations {
		if minimock.Equal(e.params, mmSetContent.defaultExpectation.params) {
			mmSetContent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetContent.defaultExpectation.params)
		}
	}

	return mmSetContent
}

// Inspect accepts an inspector function that has same arguments as the Screen.SetContent
func (mmSetContent *mScreenMockSetContent) Inspect(f func(x int, y int, mainc rune, combc []rune, style mm_tcell.Style)) *mScreenMockSetContent {
	if mmSetContent.mock.inspectFuncSetContent != nil {
		mmSetContent.mock.t.Fatalf("Inspect function is already set for ScreenMock.SetContent")
	}

	mmSetContent.mock.inspectFuncSetContent = f

	return mmSetContent
}

// Return sets up results that will be returned by Screen.SetContent
func (mmSetContent *mScreenMockSetContent) Return() *ScreenMock {
	if mmSetContent.mock.funcSetContent != nil {
		mmSetContent.mock.t.Fatalf("ScreenMock.SetContent mock is already set by Set")
	}

	if mmSetContent.defaultExpectation == nil {
		mmSetContent.defaultExpectation = &ScreenMockSetContentExpectation{mock: mmSetContent.mock}
	}

	return mmSetContent.mock
}

//Set uses given function f to mock the Screen.SetContent method
func (mmSetContent *mScreenMockSetContent) Set(f func(x int, y int, mainc rune, combc []rune, style mm_tcell.Style)) *ScreenMock {
	if mmSetContent.defaultExpectation != nil {
		mmSetContent.mock.t.Fatalf("Default expectation is already set for the Screen.SetContent method")
	}

	if len(mmSetContent.expectations) > 0 {
		mmSetContent.mock.t.Fatalf("Some expectations are already set for the Screen.SetContent method")
	}

	mmSetContent.mock.funcSetContent = f
	return mmSetContent.mock
}

// SetContent implements tcell.Screen
func (mmSetContent *ScreenMock) SetContent(x int, y int, mainc rune, combc []rune, style mm_tcell.Style) {
	mm_atomic.AddUint64(&mmSetContent.beforeSetContentCounter, 1)
	defer mm_atomic.AddUint64(&mmSetContent.afterSetContentCounter, 1)

	if mmSetContent.inspectFuncSetContent != nil {
		mmSetContent.inspectFuncSetContent(x, y, mainc, combc, style)
	}

	mm_params := &ScreenMockSetContentParams{x, y, mainc, combc, style}

	// Record call args
	mmSetContent.SetContentMock.mutex.Lock()
	mmSetContent.SetContentMock.callArgs = append(mmSetContent.SetContentMock.callArgs, mm_params)
	mmSetContent.SetContentMock.mutex.Unlock()

	for _, e := range mmSetContent.SetContentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetContent.SetContentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetContent.SetContentMock.defaultExpectation.Counter, 1)
		mm_want := mmSetContent.SetContentMock.defaultExpectation.params
		mm_got := ScreenMockSetContentParams{x, y, mainc, combc, style}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetContent.t.Errorf("ScreenMock.SetContent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetContent.funcSetContent != nil {
		mmSetContent.funcSetContent(x, y, mainc, combc, style)
		return
	}
	mmSetContent.t.Fatalf("Unexpected call to ScreenMock.SetContent. %v %v %v %v %v", x, y, mainc, combc, style)

}

// SetContentAfterCounter returns a count of finished ScreenMock.SetContent invocations
func (mmSetContent *ScreenMock) SetContentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetContent.afterSetContentCounter)
}

// SetContentBeforeCounter returns a count of ScreenMock.SetContent invocations
func (mmSetContent *ScreenMock) SetContentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetContent.beforeSetContentCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.SetContent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetContent *mScreenMockSetContent) Calls() []*ScreenMockSetContentParams {
	mmSetContent.mutex.RLock()

	argCopy := make([]*ScreenMockSetContentParams, len(mmSetContent.callArgs))
	copy(argCopy, mmSetContent.callArgs)

	mmSetContent.mutex.RUnlock()

	return argCopy
}

// MinimockSetContentDone returns true if the count of the SetContent invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockSetContentDone() bool {
	for _, e := range m.SetContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetContentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetContentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetContent != nil && mm_atomic.LoadUint64(&m.afterSetContentCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetContentInspect logs each unmet expectation
func (m *ScreenMock) MinimockSetContentInspect() {
	for _, e := range m.SetContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.SetContent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetContentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetContentCounter) < 1 {
		if m.SetContentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.SetContent")
		} else {
			m.t.Errorf("Expected call to ScreenMock.SetContent with params: %#v", *m.SetContentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetContent != nil && mm_atomic.LoadUint64(&m.afterSetContentCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.SetContent")
	}
}

type mScreenMockSetStyle struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockSetStyleExpectation
	expectations       []*ScreenMockSetStyleExpectation

	callArgs []*ScreenMockSetStyleParams
	mutex    sync.RWMutex
}

// ScreenMockSetStyleExpectation specifies expectation struct of the Screen.SetStyle
type ScreenMockSetStyleExpectation struct {
	mock   *ScreenMock
	params *ScreenMockSetStyleParams

	Counter uint64
}

// ScreenMockSetStyleParams contains parameters of the Screen.SetStyle
type ScreenMockSetStyleParams struct {
	style mm_tcell.Style
}

// Expect sets up expected params for Screen.SetStyle
func (mmSetStyle *mScreenMockSetStyle) Expect(style mm_tcell.Style) *mScreenMockSetStyle {
	if mmSetStyle.mock.funcSetStyle != nil {
		mmSetStyle.mock.t.Fatalf("ScreenMock.SetStyle mock is already set by Set")
	}

	if mmSetStyle.defaultExpectation == nil {
		mmSetStyle.defaultExpectation = &ScreenMockSetStyleExpectation{}
	}

	mmSetStyle.defaultExpectation.params = &ScreenMockSetStyleParams{style}
	for _, e := range mmSetStyle.expectations {
		if minimock.Equal(e.params, mmSetStyle.defaultExpectation.params) {
			mmSetStyle.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStyle.defaultExpectation.params)
		}
	}

	return mmSetStyle
}

// Inspect accepts an inspector function that has same arguments as the Screen.SetStyle
func (mmSetStyle *mScreenMockSetStyle) Inspect(f func(style mm_tcell.Style)) *mScreenMockSetStyle {
	if mmSetStyle.mock.inspectFuncSetStyle != nil {
		mmSetStyle.mock.t.Fatalf("Inspect function is already set for ScreenMock.SetStyle")
	}

	mmSetStyle.mock.inspectFuncSetStyle = f

	return mmSetStyle
}

// Return sets up results that will be returned by Screen.SetStyle
func (mmSetStyle *mScreenMockSetStyle) Return() *ScreenMock {
	if mmSetStyle.mock.funcSetStyle != nil {
		mmSetStyle.mock.t.Fatalf("ScreenMock.SetStyle mock is already set by Set")
	}

	if mmSetStyle.defaultExpectation == nil {
		mmSetStyle.defaultExpectation = &ScreenMockSetStyleExpectation{mock: mmSetStyle.mock}
	}

	return mmSetStyle.mock
}

//Set uses given function f to mock the Screen.SetStyle method
func (mmSetStyle *mScreenMockSetStyle) Set(f func(style mm_tcell.Style)) *ScreenMock {
	if mmSetStyle.defaultExpectation != nil {
		mmSetStyle.mock.t.Fatalf("Default expectation is already set for the Screen.SetStyle method")
	}

	if len(mmSetStyle.expectations) > 0 {
		mmSetStyle.mock.t.Fatalf("Some expectations are already set for the Screen.SetStyle method")
	}

	mmSetStyle.mock.funcSetStyle = f
	return mmSetStyle.mock
}

// SetStyle implements tcell.Screen
func (mmSetStyle *ScreenMock) SetStyle(style mm_tcell.Style) {
	mm_atomic.AddUint64(&mmSetStyle.beforeSetStyleCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStyle.afterSetStyleCounter, 1)

	if mmSetStyle.inspectFuncSetStyle != nil {
		mmSetStyle.inspectFuncSetStyle(style)
	}

	mm_params := &ScreenMockSetStyleParams{style}

	// Record call args
	mmSetStyle.SetStyleMock.mutex.Lock()
	mmSetStyle.SetStyleMock.callArgs = append(mmSetStyle.SetStyleMock.callArgs, mm_params)
	mmSetStyle.SetStyleMock.mutex.Unlock()

	for _, e := range mmSetStyle.SetStyleMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetStyle.SetStyleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStyle.SetStyleMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStyle.SetStyleMock.defaultExpectation.params
		mm_got := ScreenMockSetStyleParams{style}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStyle.t.Errorf("ScreenMock.SetStyle got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetStyle.funcSetStyle != nil {
		mmSetStyle.funcSetStyle(style)
		return
	}
	mmSetStyle.t.Fatalf("Unexpected call to ScreenMock.SetStyle. %v", style)

}

// SetStyleAfterCounter returns a count of finished ScreenMock.SetStyle invocations
func (mmSetStyle *ScreenMock) SetStyleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStyle.afterSetStyleCounter)
}

// SetStyleBeforeCounter returns a count of ScreenMock.SetStyle invocations
func (mmSetStyle *ScreenMock) SetStyleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStyle.beforeSetStyleCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.SetStyle.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStyle *mScreenMockSetStyle) Calls() []*ScreenMockSetStyleParams {
	mmSetStyle.mutex.RLock()

	argCopy := make([]*ScreenMockSetStyleParams, len(mmSetStyle.callArgs))
	copy(argCopy, mmSetStyle.callArgs)

	mmSetStyle.mutex.RUnlock()

	return argCopy
}

// MinimockSetStyleDone returns true if the count of the SetStyle invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockSetStyleDone() bool {
	for _, e := range m.SetStyleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStyleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStyleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStyle != nil && mm_atomic.LoadUint64(&m.afterSetStyleCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetStyleInspect logs each unmet expectation
func (m *ScreenMock) MinimockSetStyleInspect() {
	for _, e := range m.SetStyleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.SetStyle with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetStyleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetStyleCounter) < 1 {
		if m.SetStyleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.SetStyle")
		} else {
			m.t.Errorf("Expected call to ScreenMock.SetStyle with params: %#v", *m.SetStyleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStyle != nil && mm_atomic.LoadUint64(&m.afterSetStyleCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.SetStyle")
	}
}

type mScreenMockShow struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockShowExpectation
	expectations       []*ScreenMockShowExpectation
}

// ScreenMockShowExpectation specifies expectation struct of the Screen.Show
type ScreenMockShowExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.Show
func (mmShow *mScreenMockShow) Expect() *mScreenMockShow {
	if mmShow.mock.funcShow != nil {
		mmShow.mock.t.Fatalf("ScreenMock.Show mock is already set by Set")
	}

	if mmShow.defaultExpectation == nil {
		mmShow.defaultExpectation = &ScreenMockShowExpectation{}
	}

	return mmShow
}

// Inspect accepts an inspector function that has same arguments as the Screen.Show
func (mmShow *mScreenMockShow) Inspect(f func()) *mScreenMockShow {
	if mmShow.mock.inspectFuncShow != nil {
		mmShow.mock.t.Fatalf("Inspect function is already set for ScreenMock.Show")
	}

	mmShow.mock.inspectFuncShow = f

	return mmShow
}

// Return sets up results that will be returned by Screen.Show
func (mmShow *mScreenMockShow) Return() *ScreenMock {
	if mmShow.mock.funcShow != nil {
		mmShow.mock.t.Fatalf("ScreenMock.Show mock is already set by Set")
	}

	if mmShow.defaultExpectation == nil {
		mmShow.defaultExpectation = &ScreenMockShowExpectation{mock: mmShow.mock}
	}

	return mmShow.mock
}

//Set uses given function f to mock the Screen.Show method
func (mmShow *mScreenMockShow) Set(f func()) *ScreenMock {
	if mmShow.defaultExpectation != nil {
		mmShow.mock.t.Fatalf("Default expectation is already set for the Screen.Show method")
	}

	if len(mmShow.expectations) > 0 {
		mmShow.mock.t.Fatalf("Some expectations are already set for the Screen.Show method")
	}

	mmShow.mock.funcShow = f
	return mmShow.mock
}

// Show implements tcell.Screen
func (mmShow *ScreenMock) Show() {
	mm_atomic.AddUint64(&mmShow.beforeShowCounter, 1)
	defer mm_atomic.AddUint64(&mmShow.afterShowCounter, 1)

	if mmShow.inspectFuncShow != nil {
		mmShow.inspectFuncShow()
	}

	if mmShow.ShowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShow.ShowMock.defaultExpectation.Counter, 1)

		return

	}
	if mmShow.funcShow != nil {
		mmShow.funcShow()
		return
	}
	mmShow.t.Fatalf("Unexpected call to ScreenMock.Show.")

}

// ShowAfterCounter returns a count of finished ScreenMock.Show invocations
func (mmShow *ScreenMock) ShowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShow.afterShowCounter)
}

// ShowBeforeCounter returns a count of ScreenMock.Show invocations
func (mmShow *ScreenMock) ShowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShow.beforeShowCounter)
}

// MinimockShowDone returns true if the count of the Show invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockShowDone() bool {
	for _, e := range m.ShowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShowCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShow != nil && mm_atomic.LoadUint64(&m.afterShowCounter) < 1 {
		return false
	}
	return true
}

// MinimockShowInspect logs each unmet expectation
func (m *ScreenMock) MinimockShowInspect() {
	for _, e := range m.ShowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.Show")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShowCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Show")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShow != nil && mm_atomic.LoadUint64(&m.afterShowCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Show")
	}
}

type mScreenMockShowCursor struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockShowCursorExpectation
	expectations       []*ScreenMockShowCursorExpectation

	callArgs []*ScreenMockShowCursorParams
	mutex    sync.RWMutex
}

// ScreenMockShowCursorExpectation specifies expectation struct of the Screen.ShowCursor
type ScreenMockShowCursorExpectation struct {
	mock   *ScreenMock
	params *ScreenMockShowCursorParams

	Counter uint64
}

// ScreenMockShowCursorParams contains parameters of the Screen.ShowCursor
type ScreenMockShowCursorParams struct {
	x int
	y int
}

// Expect sets up expected params for Screen.ShowCursor
func (mmShowCursor *mScreenMockShowCursor) Expect(x int, y int) *mScreenMockShowCursor {
	if mmShowCursor.mock.funcShowCursor != nil {
		mmShowCursor.mock.t.Fatalf("ScreenMock.ShowCursor mock is already set by Set")
	}

	if mmShowCursor.defaultExpectation == nil {
		mmShowCursor.defaultExpectation = &ScreenMockShowCursorExpectation{}
	}

	mmShowCursor.defaultExpectation.params = &ScreenMockShowCursorParams{x, y}
	for _, e := range mmShowCursor.expectations {
		if minimock.Equal(e.params, mmShowCursor.defaultExpectation.params) {
			mmShowCursor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShowCursor.defaultExpectation.params)
		}
	}

	return mmShowCursor
}

// Inspect accepts an inspector function that has same arguments as the Screen.ShowCursor
func (mmShowCursor *mScreenMockShowCursor) Inspect(f func(x int, y int)) *mScreenMockShowCursor {
	if mmShowCursor.mock.inspectFuncShowCursor != nil {
		mmShowCursor.mock.t.Fatalf("Inspect function is already set for ScreenMock.ShowCursor")
	}

	mmShowCursor.mock.inspectFuncShowCursor = f

	return mmShowCursor
}

// Return sets up results that will be returned by Screen.ShowCursor
func (mmShowCursor *mScreenMockShowCursor) Return() *ScreenMock {
	if mmShowCursor.mock.funcShowCursor != nil {
		mmShowCursor.mock.t.Fatalf("ScreenMock.ShowCursor mock is already set by Set")
	}

	if mmShowCursor.defaultExpectation == nil {
		mmShowCursor.defaultExpectation = &ScreenMockShowCursorExpectation{mock: mmShowCursor.mock}
	}

	return mmShowCursor.mock
}

//Set uses given function f to mock the Screen.ShowCursor method
func (mmShowCursor *mScreenMockShowCursor) Set(f func(x int, y int)) *ScreenMock {
	if mmShowCursor.defaultExpectation != nil {
		mmShowCursor.mock.t.Fatalf("Default expectation is already set for the Screen.ShowCursor method")
	}

	if len(mmShowCursor.expectations) > 0 {
		mmShowCursor.mock.t.Fatalf("Some expectations are already set for the Screen.ShowCursor method")
	}

	mmShowCursor.mock.funcShowCursor = f
	return mmShowCursor.mock
}

// ShowCursor implements tcell.Screen
func (mmShowCursor *ScreenMock) ShowCursor(x int, y int) {
	mm_atomic.AddUint64(&mmShowCursor.beforeShowCursorCounter, 1)
	defer mm_atomic.AddUint64(&mmShowCursor.afterShowCursorCounter, 1)

	if mmShowCursor.inspectFuncShowCursor != nil {
		mmShowCursor.inspectFuncShowCursor(x, y)
	}

	mm_params := &ScreenMockShowCursorParams{x, y}

	// Record call args
	mmShowCursor.ShowCursorMock.mutex.Lock()
	mmShowCursor.ShowCursorMock.callArgs = append(mmShowCursor.ShowCursorMock.callArgs, mm_params)
	mmShowCursor.ShowCursorMock.mutex.Unlock()

	for _, e := range mmShowCursor.ShowCursorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmShowCursor.ShowCursorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShowCursor.ShowCursorMock.defaultExpectation.Counter, 1)
		mm_want := mmShowCursor.ShowCursorMock.defaultExpectation.params
		mm_got := ScreenMockShowCursorParams{x, y}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShowCursor.t.Errorf("ScreenMock.ShowCursor got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmShowCursor.funcShowCursor != nil {
		mmShowCursor.funcShowCursor(x, y)
		return
	}
	mmShowCursor.t.Fatalf("Unexpected call to ScreenMock.ShowCursor. %v %v", x, y)

}

// ShowCursorAfterCounter returns a count of finished ScreenMock.ShowCursor invocations
func (mmShowCursor *ScreenMock) ShowCursorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowCursor.afterShowCursorCounter)
}

// ShowCursorBeforeCounter returns a count of ScreenMock.ShowCursor invocations
func (mmShowCursor *ScreenMock) ShowCursorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShowCursor.beforeShowCursorCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.ShowCursor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShowCursor *mScreenMockShowCursor) Calls() []*ScreenMockShowCursorParams {
	mmShowCursor.mutex.RLock()

	argCopy := make([]*ScreenMockShowCursorParams, len(mmShowCursor.callArgs))
	copy(argCopy, mmShowCursor.callArgs)

	mmShowCursor.mutex.RUnlock()

	return argCopy
}

// MinimockShowCursorDone returns true if the count of the ShowCursor invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockShowCursorDone() bool {
	for _, e := range m.ShowCursorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShowCursorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShowCursorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShowCursor != nil && mm_atomic.LoadUint64(&m.afterShowCursorCounter) < 1 {
		return false
	}
	return true
}

// MinimockShowCursorInspect logs each unmet expectation
func (m *ScreenMock) MinimockShowCursorInspect() {
	for _, e := range m.ShowCursorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.ShowCursor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShowCursorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShowCursorCounter) < 1 {
		if m.ShowCursorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.ShowCursor")
		} else {
			m.t.Errorf("Expected call to ScreenMock.ShowCursor with params: %#v", *m.ShowCursorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShowCursor != nil && mm_atomic.LoadUint64(&m.afterShowCursorCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.ShowCursor")
	}
}

type mScreenMockSize struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockSizeExpectation
	expectations       []*ScreenMockSizeExpectation
}

// ScreenMockSizeExpectation specifies expectation struct of the Screen.Size
type ScreenMockSizeExpectation struct {
	mock *ScreenMock

	results *ScreenMockSizeResults
	Counter uint64
}

// ScreenMockSizeResults contains results of the Screen.Size
type ScreenMockSizeResults struct {
	i1 int
	i2 int
}

// Expect sets up expected params for Screen.Size
func (mmSize *mScreenMockSize) Expect() *mScreenMockSize {
	if mmSize.mock.funcSize != nil {
		mmSize.mock.t.Fatalf("ScreenMock.Size mock is already set by Set")
	}

	if mmSize.defaultExpectation == nil {
		mmSize.defaultExpectation = &ScreenMockSizeExpectation{}
	}

	return mmSize
}

// Inspect accepts an inspector function that has same arguments as the Screen.Size
func (mmSize *mScreenMockSize) Inspect(f func()) *mScreenMockSize {
	if mmSize.mock.inspectFuncSize != nil {
		mmSize.mock.t.Fatalf("Inspect function is already set for ScreenMock.Size")
	}

	mmSize.mock.inspectFuncSize = f

	return mmSize
}

// Return sets up results that will be returned by Screen.Size
func (mmSize *mScreenMockSize) Return(i1 int, i2 int) *ScreenMock {
	if mmSize.mock.funcSize != nil {
		mmSize.mock.t.Fatalf("ScreenMock.Size mock is already set by Set")
	}

	if mmSize.defaultExpectation == nil {
		mmSize.defaultExpectation = &ScreenMockSizeExpectation{mock: mmSize.mock}
	}
	mmSize.defaultExpectation.results = &ScreenMockSizeResults{i1, i2}
	return mmSize.mock
}

//Set uses given function f to mock the Screen.Size method
func (mmSize *mScreenMockSize) Set(f func() (i1 int, i2 int)) *ScreenMock {
	if mmSize.defaultExpectation != nil {
		mmSize.mock.t.Fatalf("Default expectation is already set for the Screen.Size method")
	}

	if len(mmSize.expectations) > 0 {
		mmSize.mock.t.Fatalf("Some expectations are already set for the Screen.Size method")
	}

	mmSize.mock.funcSize = f
	return mmSize.mock
}

// Size implements tcell.Screen
func (mmSize *ScreenMock) Size() (i1 int, i2 int) {
	mm_atomic.AddUint64(&mmSize.beforeSizeCounter, 1)
	defer mm_atomic.AddUint64(&mmSize.afterSizeCounter, 1)

	if mmSize.inspectFuncSize != nil {
		mmSize.inspectFuncSize()
	}

	if mmSize.SizeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSize.SizeMock.defaultExpectation.Counter, 1)

		mm_results := mmSize.SizeMock.defaultExpectation.results
		if mm_results == nil {
			mmSize.t.Fatal("No results are set for the ScreenMock.Size")
		}
		return (*mm_results).i1, (*mm_results).i2
	}
	if mmSize.funcSize != nil {
		return mmSize.funcSize()
	}
	mmSize.t.Fatalf("Unexpected call to ScreenMock.Size.")
	return
}

// SizeAfterCounter returns a count of finished ScreenMock.Size invocations
func (mmSize *ScreenMock) SizeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSize.afterSizeCounter)
}

// SizeBeforeCounter returns a count of ScreenMock.Size invocations
func (mmSize *ScreenMock) SizeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSize.beforeSizeCounter)
}

// MinimockSizeDone returns true if the count of the Size invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockSizeDone() bool {
	for _, e := range m.SizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSizeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSize != nil && mm_atomic.LoadUint64(&m.afterSizeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSizeInspect logs each unmet expectation
func (m *ScreenMock) MinimockSizeInspect() {
	for _, e := range m.SizeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.Size")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SizeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSizeCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Size")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSize != nil && mm_atomic.LoadUint64(&m.afterSizeCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Size")
	}
}

type mScreenMockSync struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockSyncExpectation
	expectations       []*ScreenMockSyncExpectation
}

// ScreenMockSyncExpectation specifies expectation struct of the Screen.Sync
type ScreenMockSyncExpectation struct {
	mock *ScreenMock

	Counter uint64
}

// Expect sets up expected params for Screen.Sync
func (mmSync *mScreenMockSync) Expect() *mScreenMockSync {
	if mmSync.mock.funcSync != nil {
		mmSync.mock.t.Fatalf("ScreenMock.Sync mock is already set by Set")
	}

	if mmSync.defaultExpectation == nil {
		mmSync.defaultExpectation = &ScreenMockSyncExpectation{}
	}

	return mmSync
}

// Inspect accepts an inspector function that has same arguments as the Screen.Sync
func (mmSync *mScreenMockSync) Inspect(f func()) *mScreenMockSync {
	if mmSync.mock.inspectFuncSync != nil {
		mmSync.mock.t.Fatalf("Inspect function is already set for ScreenMock.Sync")
	}

	mmSync.mock.inspectFuncSync = f

	return mmSync
}

// Return sets up results that will be returned by Screen.Sync
func (mmSync *mScreenMockSync) Return() *ScreenMock {
	if mmSync.mock.funcSync != nil {
		mmSync.mock.t.Fatalf("ScreenMock.Sync mock is already set by Set")
	}

	if mmSync.defaultExpectation == nil {
		mmSync.defaultExpectation = &ScreenMockSyncExpectation{mock: mmSync.mock}
	}

	return mmSync.mock
}

//Set uses given function f to mock the Screen.Sync method
func (mmSync *mScreenMockSync) Set(f func()) *ScreenMock {
	if mmSync.defaultExpectation != nil {
		mmSync.mock.t.Fatalf("Default expectation is already set for the Screen.Sync method")
	}

	if len(mmSync.expectations) > 0 {
		mmSync.mock.t.Fatalf("Some expectations are already set for the Screen.Sync method")
	}

	mmSync.mock.funcSync = f
	return mmSync.mock
}

// Sync implements tcell.Screen
func (mmSync *ScreenMock) Sync() {
	mm_atomic.AddUint64(&mmSync.beforeSyncCounter, 1)
	defer mm_atomic.AddUint64(&mmSync.afterSyncCounter, 1)

	if mmSync.inspectFuncSync != nil {
		mmSync.inspectFuncSync()
	}

	if mmSync.SyncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSync.SyncMock.defaultExpectation.Counter, 1)

		return

	}
	if mmSync.funcSync != nil {
		mmSync.funcSync()
		return
	}
	mmSync.t.Fatalf("Unexpected call to ScreenMock.Sync.")

}

// SyncAfterCounter returns a count of finished ScreenMock.Sync invocations
func (mmSync *ScreenMock) SyncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSync.afterSyncCounter)
}

// SyncBeforeCounter returns a count of ScreenMock.Sync invocations
func (mmSync *ScreenMock) SyncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSync.beforeSyncCounter)
}

// MinimockSyncDone returns true if the count of the Sync invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockSyncDone() bool {
	for _, e := range m.SyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSync != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		return false
	}
	return true
}

// MinimockSyncInspect logs each unmet expectation
func (m *ScreenMock) MinimockSyncInspect() {
	for _, e := range m.SyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ScreenMock.Sync")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Sync")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSync != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.Sync")
	}
}

type mScreenMockUnregisterRuneFallback struct {
	mock               *ScreenMock
	defaultExpectation *ScreenMockUnregisterRuneFallbackExpectation
	expectations       []*ScreenMockUnregisterRuneFallbackExpectation

	callArgs []*ScreenMockUnregisterRuneFallbackParams
	mutex    sync.RWMutex
}

// ScreenMockUnregisterRuneFallbackExpectation specifies expectation struct of the Screen.UnregisterRuneFallback
type ScreenMockUnregisterRuneFallbackExpectation struct {
	mock   *ScreenMock
	params *ScreenMockUnregisterRuneFallbackParams

	Counter uint64
}

// ScreenMockUnregisterRuneFallbackParams contains parameters of the Screen.UnregisterRuneFallback
type ScreenMockUnregisterRuneFallbackParams struct {
	r rune
}

// Expect sets up expected params for Screen.UnregisterRuneFallback
func (mmUnregisterRuneFallback *mScreenMockUnregisterRuneFallback) Expect(r rune) *mScreenMockUnregisterRuneFallback {
	if mmUnregisterRuneFallback.mock.funcUnregisterRuneFallback != nil {
		mmUnregisterRuneFallback.mock.t.Fatalf("ScreenMock.UnregisterRuneFallback mock is already set by Set")
	}

	if mmUnregisterRuneFallback.defaultExpectation == nil {
		mmUnregisterRuneFallback.defaultExpectation = &ScreenMockUnregisterRuneFallbackExpectation{}
	}

	mmUnregisterRuneFallback.defaultExpectation.params = &ScreenMockUnregisterRuneFallbackParams{r}
	for _, e := range mmUnregisterRuneFallback.expectations {
		if minimock.Equal(e.params, mmUnregisterRuneFallback.defaultExpectation.params) {
			mmUnregisterRuneFallback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnregisterRuneFallback.defaultExpectation.params)
		}
	}

	return mmUnregisterRuneFallback
}

// Inspect accepts an inspector function that has same arguments as the Screen.UnregisterRuneFallback
func (mmUnregisterRuneFallback *mScreenMockUnregisterRuneFallback) Inspect(f func(r rune)) *mScreenMockUnregisterRuneFallback {
	if mmUnregisterRuneFallback.mock.inspectFuncUnregisterRuneFallback != nil {
		mmUnregisterRuneFallback.mock.t.Fatalf("Inspect function is already set for ScreenMock.UnregisterRuneFallback")
	}

	mmUnregisterRuneFallback.mock.inspectFuncUnregisterRuneFallback = f

	return mmUnregisterRuneFallback
}

// Return sets up results that will be returned by Screen.UnregisterRuneFallback
func (mmUnregisterRuneFallback *mScreenMockUnregisterRuneFallback) Return() *ScreenMock {
	if mmUnregisterRuneFallback.mock.funcUnregisterRuneFallback != nil {
		mmUnregisterRuneFallback.mock.t.Fatalf("ScreenMock.UnregisterRuneFallback mock is already set by Set")
	}

	if mmUnregisterRuneFallback.defaultExpectation == nil {
		mmUnregisterRuneFallback.defaultExpectation = &ScreenMockUnregisterRuneFallbackExpectation{mock: mmUnregisterRuneFallback.mock}
	}

	return mmUnregisterRuneFallback.mock
}

//Set uses given function f to mock the Screen.UnregisterRuneFallback method
func (mmUnregisterRuneFallback *mScreenMockUnregisterRuneFallback) Set(f func(r rune)) *ScreenMock {
	if mmUnregisterRuneFallback.defaultExpectation != nil {
		mmUnregisterRuneFallback.mock.t.Fatalf("Default expectation is already set for the Screen.UnregisterRuneFallback method")
	}

	if len(mmUnregisterRuneFallback.expectations) > 0 {
		mmUnregisterRuneFallback.mock.t.Fatalf("Some expectations are already set for the Screen.UnregisterRuneFallback method")
	}

	mmUnregisterRuneFallback.mock.funcUnregisterRuneFallback = f
	return mmUnregisterRuneFallback.mock
}

// UnregisterRuneFallback implements tcell.Screen
func (mmUnregisterRuneFallback *ScreenMock) UnregisterRuneFallback(r rune) {
	mm_atomic.AddUint64(&mmUnregisterRuneFallback.beforeUnregisterRuneFallbackCounter, 1)
	defer mm_atomic.AddUint64(&mmUnregisterRuneFallback.afterUnregisterRuneFallbackCounter, 1)

	if mmUnregisterRuneFallback.inspectFuncUnregisterRuneFallback != nil {
		mmUnregisterRuneFallback.inspectFuncUnregisterRuneFallback(r)
	}

	mm_params := &ScreenMockUnregisterRuneFallbackParams{r}

	// Record call args
	mmUnregisterRuneFallback.UnregisterRuneFallbackMock.mutex.Lock()
	mmUnregisterRuneFallback.UnregisterRuneFallbackMock.callArgs = append(mmUnregisterRuneFallback.UnregisterRuneFallbackMock.callArgs, mm_params)
	mmUnregisterRuneFallback.UnregisterRuneFallbackMock.mutex.Unlock()

	for _, e := range mmUnregisterRuneFallback.UnregisterRuneFallbackMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmUnregisterRuneFallback.UnregisterRuneFallbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnregisterRuneFallback.UnregisterRuneFallbackMock.defaultExpectation.Counter, 1)
		mm_want := mmUnregisterRuneFallback.UnregisterRuneFallbackMock.defaultExpectation.params
		mm_got := ScreenMockUnregisterRuneFallbackParams{r}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnregisterRuneFallback.t.Errorf("ScreenMock.UnregisterRuneFallback got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmUnregisterRuneFallback.funcUnregisterRuneFallback != nil {
		mmUnregisterRuneFallback.funcUnregisterRuneFallback(r)
		return
	}
	mmUnregisterRuneFallback.t.Fatalf("Unexpected call to ScreenMock.UnregisterRuneFallback. %v", r)

}

// UnregisterRuneFallbackAfterCounter returns a count of finished ScreenMock.UnregisterRuneFallback invocations
func (mmUnregisterRuneFallback *ScreenMock) UnregisterRuneFallbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnregisterRuneFallback.afterUnregisterRuneFallbackCounter)
}

// UnregisterRuneFallbackBeforeCounter returns a count of ScreenMock.UnregisterRuneFallback invocations
func (mmUnregisterRuneFallback *ScreenMock) UnregisterRuneFallbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnregisterRuneFallback.beforeUnregisterRuneFallbackCounter)
}

// Calls returns a list of arguments used in each call to ScreenMock.UnregisterRuneFallback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnregisterRuneFallback *mScreenMockUnregisterRuneFallback) Calls() []*ScreenMockUnregisterRuneFallbackParams {
	mmUnregisterRuneFallback.mutex.RLock()

	argCopy := make([]*ScreenMockUnregisterRuneFallbackParams, len(mmUnregisterRuneFallback.callArgs))
	copy(argCopy, mmUnregisterRuneFallback.callArgs)

	mmUnregisterRuneFallback.mutex.RUnlock()

	return argCopy
}

// MinimockUnregisterRuneFallbackDone returns true if the count of the UnregisterRuneFallback invocations corresponds
// the number of defined expectations
func (m *ScreenMock) MinimockUnregisterRuneFallbackDone() bool {
	for _, e := range m.UnregisterRuneFallbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnregisterRuneFallbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnregisterRuneFallbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnregisterRuneFallback != nil && mm_atomic.LoadUint64(&m.afterUnregisterRuneFallbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnregisterRuneFallbackInspect logs each unmet expectation
func (m *ScreenMock) MinimockUnregisterRuneFallbackInspect() {
	for _, e := range m.UnregisterRuneFallbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ScreenMock.UnregisterRuneFallback with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnregisterRuneFallbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnregisterRuneFallbackCounter) < 1 {
		if m.UnregisterRuneFallbackMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ScreenMock.UnregisterRuneFallback")
		} else {
			m.t.Errorf("Expected call to ScreenMock.UnregisterRuneFallback with params: %#v", *m.UnregisterRuneFallbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnregisterRuneFallback != nil && mm_atomic.LoadUint64(&m.afterUnregisterRuneFallbackCounter) < 1 {
		m.t.Error("Expected call to ScreenMock.UnregisterRuneFallback")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ScreenMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockBeepInspect()

		m.MinimockCanDisplayInspect()

		m.MinimockCharacterSetInspect()

		m.MinimockClearInspect()

		m.MinimockColorsInspect()

		m.MinimockDisableMouseInspect()

		m.MinimockDisablePasteInspect()

		m.MinimockEnableMouseInspect()

		m.MinimockEnablePasteInspect()

		m.MinimockFillInspect()

		m.MinimockFiniInspect()

		m.MinimockGetContentInspect()

		m.MinimockHasKeyInspect()

		m.MinimockHasMouseInspect()

		m.MinimockHideCursorInspect()

		m.MinimockInitInspect()

		m.MinimockPollEventInspect()

		m.MinimockPostEventInspect()

		m.MinimockPostEventWaitInspect()

		m.MinimockRegisterRuneFallbackInspect()

		m.MinimockResizeInspect()

		m.MinimockSetCellInspect()

		m.MinimockSetContentInspect()

		m.MinimockSetStyleInspect()

		m.MinimockShowInspect()

		m.MinimockShowCursorInspect()

		m.MinimockSizeInspect()

		m.MinimockSyncInspect()

		m.MinimockUnregisterRuneFallbackInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ScreenMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ScreenMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeepDone() &&
		m.MinimockCanDisplayDone() &&
		m.MinimockCharacterSetDone() &&
		m.MinimockClearDone() &&
		m.MinimockColorsDone() &&
		m.MinimockDisableMouseDone() &&
		m.MinimockDisablePasteDone() &&
		m.MinimockEnableMouseDone() &&
		m.MinimockEnablePasteDone() &&
		m.MinimockFillDone() &&
		m.MinimockFiniDone() &&
		m.MinimockGetContentDone() &&
		m.MinimockHasKeyDone() &&
		m.MinimockHasMouseDone() &&
		m.MinimockHideCursorDone() &&
		m.MinimockInitDone() &&
		m.MinimockPollEventDone() &&
		m.MinimockPostEventDone() &&
		m.MinimockPostEventWaitDone() &&
		m.MinimockRegisterRuneFallbackDone() &&
		m.MinimockResizeDone() &&
		m.MinimockSetCellDone() &&
		m.MinimockSetContentDone() &&
		m.MinimockSetStyleDone() &&
		m.MinimockShowDone() &&
		m.MinimockShowCursorDone() &&
		m.MinimockSizeDone() &&
		m.MinimockSyncDone() &&
		m.MinimockUnregisterRuneFallbackDone()
}
